---
layout: ../../layout/main-layout.astro
---
<a href="/object-orientation">← Object Orientation</a> <br /> <br />

# SOLID

The SOLID principles are five design principles that help create maintainable, flexible, and scalable object-oriented software. This guide demonstrates each principle using a **Library Management System** context in Dart.

## Table of Contents
1. [Single Responsibility Principle (SRP)](#1-single-responsibility-principle-srp)
2. [Open/Closed Principle (OCP)](#2-openclosed-principle-ocp)
3. [Liskov Substitution Principle (LSP)](#3-liskov-substitution-principle-lsp)
4. [Interface Segregation Principle (ISP)](#4-interface-segregation-principle-isp)
5. [Dependency Inversion Principle (DIP)](#5-dependency-inversion-principle-dip)

---

## 1. Single Responsibility Principle (SRP)

**Definition:** A class should have only one reason to change, meaning it should have only one job or responsibility.

### ❌ Violation Example

```dart
// BAD: This class has multiple responsibilities
class Book {
  String title;
  String author;
  String isbn;
  bool isAvailable;

  Book(this.title, this.author, this.isbn) : isAvailable = true;

  // Responsibility 1: Book data management
  void updateTitle(String newTitle) {
    title = newTitle;
  }

  // Responsibility 2: Persistence logic
  void saveToDatabase() {
    print('Saving book to database: $title');
    // Database saving logic
  }

  // Responsibility 3: Notification logic
  void notifyLibrarian(String message) {
    print('Email sent to librarian: $message');
    // Email sending logic
  }

  // Responsibility 4: Validation logic
  bool validateISBN() {
    return isbn.length == 13;
  }
}
```

### ✅ Correct Implementation

```dart
// GOOD: Each class has a single responsibility

// Responsibility 1: Book data representation
class Book {
  String title;
  String author;
  String isbn;
  bool isAvailable;

  Book(this.title, this.author, this.isbn) : isAvailable = true;

  void updateTitle(String newTitle) {
    title = newTitle;
  }
}

// Responsibility 2: Book persistence
class BookRepository {
  void save(Book book) {
    print('Saving book to database: ${book.title}');
    // Database saving logic
  }

  Book? findByISBN(String isbn) {
    // Database query logic
    return null;
  }
}

// Responsibility 3: Notification service
class NotificationService {
  void notifyLibrarian(String message) {
    print('Email sent to librarian: $message');
    // Email sending logic
  }
}

// Responsibility 4: Book validation
class BookValidator {
  bool validateISBN(String isbn) {
    return isbn.length == 13;
  }

  bool validateTitle(String title) {
    return title.isNotEmpty;
  }
}
```

---

## 2. Open/Closed Principle (OCP)

**Definition:** Software entities should be open for extension but closed for modification.

### ❌ Violation Example

```dart
// BAD: Adding new book types requires modifying existing code
class BookPriceCalculator {
  double calculatePrice(Book book, String bookType) {
    double basePrice = 20.0;
    
    if (bookType == 'fiction') {
      return basePrice * 1.1;
    } else if (bookType == 'academic') {
      return basePrice * 1.5;
    } else if (bookType == 'children') {
      return basePrice * 0.8;
    }
    // Adding new types requires modifying this method
    return basePrice;
  }
}
```

### ✅ Correct Implementation

```dart
// GOOD: Using abstraction to allow extension without modification

// Base class that's closed for modification
abstract class Book {
  String title;
  String author;
  String isbn;

  Book(this.title, this.author, this.isbn);

  // Abstract method that subclasses must implement
  double calculatePrice();
}

// Extensions - open for extension
class FictionBook extends Book {
  FictionBook(String title, String author, String isbn) 
      : super(title, author, isbn);

  @override
  double calculatePrice() {
    return 20.0 * 1.1; // 10% markup for fiction
  }
}

class AcademicBook extends Book {
  FictionBook(String title, String author, String isbn) 
      : super(title, author, isbn);

  @override
  double calculatePrice() {
    return 20.0 * 1.5; // 50% markup for academic books
  }
}

class ChildrenBook extends Book {
  ChildrenBook(String title, String author, String isbn) 
      : super(title, author, isbn);

  @override
  double calculatePrice() {
    return 20.0 * 0.8; // 20% discount for children books
  }
}

// Price calculator doesn't need modification for new book types
class BookPriceCalculator {
  double calculatePrice(Book book) {
    return book.calculatePrice();
  }
}

// Adding new book types without modifying existing code
class SciFiBook extends Book {
  SciFiBook(String title, String author, String isbn) 
      : super(title, author, isbn);

  @override
  double calculatePrice() {
    return 20.0 * 1.2; // 20% markup for sci-fi
  }
}
```

---

## 3. Liskov Substitution Principle (LSP)

**Definition:** Objects of a superclass should be replaceable with objects of its subclasses without breaking the application.

### ❌ Violation Example

```dart
// BAD: Digital books violate LSP because they can't be physically borrowed
class Book {
  String title;
  String author;
  bool isPhysicallyAvailable;

  Book(this.title, this.author) : isPhysicallyAvailable = true;

  void borrowPhysically() {
    if (isPhysicallyAvailable) {
      isPhysicallyAvailable = false;
      print('$title borrowed physically');
    }
  }

  void returnPhysically() {
    isPhysicallyAvailable = true;
    print('$title returned physically');
  }
}

class DigitalBook extends Book {
  DigitalBook(String title, String author) : super(title, author);

  @override
  void borrowPhysically() {
    // This violates LSP - digital books can't be borrowed physically
    throw Exception('Cannot borrow digital book physically');
  }

  @override
  void returnPhysically() {
    // This violates LSP - digital books can't be returned physically
    throw Exception('Cannot return digital book physically');
  }
}
```

### ✅ Correct Implementation

```dart
// GOOD: Proper abstraction that all subclasses can implement

abstract class LibraryItem {
  String title;
  String author;
  bool isAvailable;

  LibraryItem(this.title, this.author) : isAvailable = true;

  // All subclasses can implement these methods properly
  void borrow();
  void returnItem();
  String getAccessMethod();
}

class PhysicalBook extends LibraryItem {
  String shelfLocation;

  PhysicalBook(String title, String author, this.shelfLocation) 
      : super(title, author);

  @override
  void borrow() {
    if (isAvailable) {
      isAvailable = false;
      print('Physical book "$title" borrowed from shelf $shelfLocation');
    }
  }

  @override
  void returnItem() {
    isAvailable = true;
    print('Physical book "$title" returned to shelf $shelfLocation');
  }

  @override
  String getAccessMethod() {
    return 'Physical access from shelf $shelfLocation';
  }
}

class DigitalBook extends LibraryItem {
  String downloadUrl;

  DigitalBook(String title, String author, this.downloadUrl) 
      : super(title, author);

  @override
  void borrow() {
    // Digital books are always "available" for download
    print('Digital book "$title" access granted. Download: $downloadUrl');
  }

  @override
  void returnItem() {
    // Digital books don't need to be "returned"
    print('Digital book "$title" access logged');
  }

  @override
  String getAccessMethod() {
    return 'Digital access via $downloadUrl';
  }
}

// This service works with any LibraryItem without knowing the specific type
class LibraryService {
  void processItemBorrow(LibraryItem item) {
    print('Processing borrow for: ${item.title}');
    item.borrow(); // Works correctly for both physical and digital books
    print('Access method: ${item.getAccessMethod()}');
  }
}
```

---

## 4. Interface Segregation Principle (ISP)

**Definition:** No client should be forced to depend on methods it does not use. Create specific interfaces rather than one general-purpose interface.

### ❌ Violation Example

```dart
// BAD: Fat interface that forces classes to implement unused methods
abstract class LibraryOperations {
  // Book operations
  void borrowBook(String isbn);
  void returnBook(String isbn);
  void renewBook(String isbn);
  
  // Member operations
  void registerMember(String memberId);
  void updateMemberInfo(String memberId);
  void deleteMember(String memberId);
  
  // Inventory operations
  void addBookToInventory(Book book);
  void removeBookFromInventory(String isbn);
  void updateBookInfo(String isbn);
  
  // Reporting operations
  void generateBorrowingReport();
  void generateInventoryReport();
  void generateMembershipReport();
}

// This class only handles book operations but must implement all methods
class BookService implements LibraryOperations {
  @override
  void borrowBook(String isbn) {
    print('Book borrowed: $isbn');
  }

  @override
  void returnBook(String isbn) {
    print('Book returned: $isbn');
  }

  @override
  void renewBook(String isbn) {
    print('Book renewed: $isbn');
  }

  // Forced to implement unused methods
  @override
  void registerMember(String memberId) {
    throw UnimplementedError('Not needed in BookService');
  }

  @override
  void updateMemberInfo(String memberId) {
    throw UnimplementedError('Not needed in BookService');
  }

  // ... all other unused methods
}
```

### ✅ Correct Implementation

```dart
// GOOD: Segregated interfaces for specific responsibilities

// Book-specific operations
abstract class BookOperations {
  void borrowBook(String isbn);
  void returnBook(String isbn);
  void renewBook(String isbn);
}

// Member-specific operations  
abstract class MemberOperations {
  void registerMember(String memberId);
  void updateMemberInfo(String memberId);
  void deleteMember(String memberId);
}

// Inventory-specific operations
abstract class InventoryOperations {
  void addBookToInventory(Book book);
  void removeBookFromInventory(String isbn);
  void updateBookInfo(String isbn);
}

// Reporting-specific operations
abstract class ReportingOperations {
  void generateBorrowingReport();
  void generateInventoryReport();
  void generateMembershipReport();
}

// Classes implement only the interfaces they need
class BookService implements BookOperations {
  @override
  void borrowBook(String isbn) {
    print('Book borrowed: $isbn');
  }

  @override
  void returnBook(String isbn) {
    print('Book returned: $isbn');
  }

  @override
  void renewBook(String isbn) {
    print('Book renewed: $isbn');
  }
}

class MemberService implements MemberOperations {
  @override
  void registerMember(String memberId) {
    print('Member registered: $memberId');
  }

  @override
  void updateMemberInfo(String memberId) {
    print('Member info updated: $memberId');
  }

  @override
  void deleteMember(String memberId) {
    print('Member deleted: $memberId');
  }
}

class InventoryService implements InventoryOperations {
  @override
  void addBookToInventory(Book book) {
    print('Book added to inventory: ${book.title}');
  }

  @override
  void removeBookFromInventory(String isbn) {
    print('Book removed from inventory: $isbn');
  }

  @override
  void updateBookInfo(String isbn) {
    print('Book info updated: $isbn');
  }
}

// A comprehensive service can implement multiple specific interfaces
class LibraryManager implements BookOperations, MemberOperations, ReportingOperations {
  final BookService _bookService = BookService();
  final MemberService _memberService = MemberService();

  // Delegate to appropriate services
  @override
  void borrowBook(String isbn) => _bookService.borrowBook(isbn);
  
  @override
  void returnBook(String isbn) => _bookService.returnBook(isbn);
  
  @override
  void renewBook(String isbn) => _bookService.renewBook(isbn);

  @override
  void registerMember(String memberId) => _memberService.registerMember(memberId);
  
  @override
  void updateMemberInfo(String memberId) => _memberService.updateMemberInfo(memberId);
  
  @override
  void deleteMember(String memberId) => _memberService.deleteMember(memberId);

  @override
  void generateBorrowingReport() {
    print('Generating borrowing report...');
  }

  @override
  void generateInventoryReport() {
    print('Generating inventory report...');
  }

  @override
  void generateMembershipReport() {
    print('Generating membership report...');
  }
}
```

---

## 5. Dependency Inversion Principle (DIP)

**Definition:** High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details; details should depend on abstractions.

### ❌ Violation Example

```dart
// BAD: High-level module depends directly on low-level modules

// Low-level modules (concrete implementations)
class DatabaseBookRepository {
  void save(Book book) {
    print('Saving book to MySQL database: ${book.title}');
    // MySQL-specific code
  }

  Book? findByISBN(String isbn) {
    print('Querying MySQL database for ISBN: $isbn');
    // MySQL-specific query
    return null;
  }
}

class EmailNotificationService {
  void sendNotification(String message) {
    print('Sending email notification: $message');
    // SMTP email sending code
  }
}

// High-level module that depends on concrete low-level modules
class LibraryService {
  // Direct dependencies on concrete classes - BAD!
  final DatabaseBookRepository _repository = DatabaseBookRepository();
  final EmailNotificationService _notificationService = EmailNotificationService();

  void borrowBook(String isbn, String memberId) {
    Book? book = _repository.findByISBN(isbn);
    if (book != null && book.isAvailable) {
      book.isAvailable = false;
      _repository.save(book);
      _notificationService.sendNotification('Book $isbn borrowed by $memberId');
    }
  }
}
```

### ✅ Correct Implementation

```dart
// GOOD: Both high-level and low-level modules depend on abstractions

// Abstractions (interfaces)
abstract class BookRepository {
  void save(Book book);
  Book? findByISBN(String isbn);
  List<Book> findAvailableBooks();
}

abstract class NotificationService {
  void sendNotification(String message);
}

// Low-level modules depend on abstractions
class DatabaseBookRepository implements BookRepository {
  @override
  void save(Book book) {
    print('Saving book to MySQL database: ${book.title}');
    // MySQL-specific implementation
  }

  @override
  Book? findByISBN(String isbn) {
    print('Querying MySQL database for ISBN: $isbn');
    // MySQL-specific query
    return Book('Sample Title', 'Sample Author', isbn);
  }

  @override
  List<Book> findAvailableBooks() {
    print('Querying available books from MySQL database');
    return [];
  }
}

class FileBookRepository implements BookRepository {
  @override
  void save(Book book) {
    print('Saving book to file system: ${book.title}');
    // File-specific implementation
  }

  @override
  Book? findByISBN(String isbn) {
    print('Searching file system for ISBN: $isbn');
    // File-specific search
    return null;
  }

  @override
  List<Book> findAvailableBooks() {
    print('Reading available books from file system');
    return [];
  }
}

class EmailNotificationService implements NotificationService {
  @override
  void sendNotification(String message) {
    print('Sending email notification: $message');
    // SMTP email implementation
  }
}

class SMSNotificationService implements NotificationService {
  @override
  void sendNotification(String message) {
    print('Sending SMS notification: $message');
    // SMS API implementation
  }
}

// High-level module depends on abstractions
class LibraryService {
  final BookRepository _repository;
  final NotificationService _notificationService;

  // Dependency injection through constructor
  LibraryService(this._repository, this._notificationService);

  void borrowBook(String isbn, String memberId) {
    Book? book = _repository.findByISBN(isbn);
    if (book != null && book.isAvailable) {
      book.isAvailable = false;
      _repository.save(book);
      _notificationService.sendNotification('Book $isbn borrowed by $memberId');
    }
  }

  void listAvailableBooks() {
    List<Book> books = _repository.findAvailableBooks();
    print('Available books: ${books.length}');
  }
}

// Dependency injection configuration
class LibraryConfiguration {
  static LibraryService createLibraryService() {
    // Easy to switch implementations
    BookRepository repository = DatabaseBookRepository(); // or FileBookRepository()
    NotificationService notificationService = EmailNotificationService(); // or SMSNotificationService()
    
    return LibraryService(repository, notificationService);
  }
}

// Usage
void main() {
  LibraryService libraryService = LibraryConfiguration.createLibraryService();
  libraryService.borrowBook('1234567890123', 'member001');
}
```

## Benefits of Following SOLID Principles

1. **Maintainability**: Code is easier to understand and modify
2. **Flexibility**: Easy to add new features without breaking existing code
3. **Testability**: Classes with single responsibilities are easier to test
4. **Reusability**: Well-designed components can be reused in different contexts
5. **Scalability**: Systems can grow without becoming overly complex

## Summary

The SOLID principles work together to create robust, maintainable software:

- **SRP**: One class, one responsibility
- **OCP**: Extend behavior without modifying existing code
- **LSP**: Subclasses should be substitutable for their base classes
- **ISP**: Use specific interfaces instead of general-purpose ones
- **DIP**: Depend on abstractions, not concretions

By applying these principles consistently in your Dart applications, you'll create code that is easier to maintain, test, and extend over time.