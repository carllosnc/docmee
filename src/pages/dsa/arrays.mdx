---
layout: ../../layout/main-layout.astro
---
<a href="/dsa">‚Üê Data Structures and Algorithms</a> <br /> <br />

# Arrays

## Table of Contents
1. [Introduction](#introduction)
2. [Array Fundamentals](#array-fundamentals)
3. [Array Declaration and Initialization](#array-declaration-and-initialization)
4. [Array Access and Manipulation](#array-access-and-manipulation)
5. [Multi-dimensional Arrays](#multi-dimensional-arrays)
6. [Dynamic Arrays](#dynamic-arrays)
7. [Array Algorithms](#array-algorithms)
8. [Memory Layout and Performance](#memory-layout-and-performance)
9. [Common Pitfalls and Best Practices](#common-pitfalls-and-best-practices)
10. [Advanced Topics](#advanced-topics)

## Introduction

Arrays are fundamental data structures in computer science that store multiple elements of the same type in contiguous memory locations. They provide efficient access to elements using indices and form the foundation for many other data structures.

### Key Characteristics
- **Homogeneous**: All elements must be of the same data type
- **Contiguous**: Elements are stored in adjacent memory locations
- **Fixed Size**: Size is determined at compile time (for static arrays)
- **Index-based**: Elements accessed using zero-based indexing

## Array Fundamentals

### Memory Representation
```c
// Array layout in memory
int arr[5] = {10, 20, 30, 40, 50};
// Memory: [10][20][30][40][50]
// Index:   0   1   2   3   4
// Address: base, base+4, base+8, base+12, base+16
```

### Time Complexity
- **Access**: O(1) - Direct memory address calculation
- **Search**: O(n) - Linear search through elements
- **Insertion**: O(n) - May require shifting elements
- **Deletion**: O(n) - May require shifting elements

## Array Declaration and Initialization

### Static Array Declaration
```c
#include <stdio.h>

int main() {
    // Declaration with size
    int numbers[10];
    
    // Declaration with initialization
    int primes[] = {2, 3, 5, 7, 11};
    
    // Declaration with size and partial initialization
    int scores[5] = {85, 90}; // Rest initialized to 0
    
    // Declaration with designated initializers (C99)
    int sparse[10] = {[0] = 1, [4] = 5, [9] = 10};
    
    return 0;
}
```

### Character Arrays (Strings)
```c
#include <stdio.h>
#include <string.h>

int main() {
    // Character array initialization methods
    char str1[] = "Hello";           // Size automatically determined
    char str2[10] = "World";         // Explicit size
    char str3[] = {'H', 'i', '\0'};  // Character-by-character
    
    // String manipulation
    printf("str1: %s\n", str1);
    printf("Length of str1: %lu\n", strlen(str1));
    
    return 0;
}
```

### Array Size Calculation
```c
#include <stdio.h>

int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // Calculate array size
    size_t size = sizeof(arr) / sizeof(arr[0]);
    printf("Array size: %zu\n", size);
    
    // Using macro for reusability
    #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
    printf("Array size (macro): %zu\n", ARRAY_SIZE(arr));
    
    return 0;
}
```

## Array Access and Manipulation

### Basic Operations
```c
#include <stdio.h>

void printArray(int arr[], int size) {
    printf("Array: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int numbers[5] = {10, 20, 30, 40, 50};
    
    // Reading elements
    printf("First element: %d\n", numbers[0]);
    printf("Last element: %d\n", numbers[4]);
    
    // Modifying elements
    numbers[2] = 35;
    
    // Array traversal
    printArray(numbers, 5);
    
    return 0;
}
```

### Array Input and Output
```c
#include <stdio.h>

int main() {
    int size;
    printf("Enter array size: ");
    scanf("%d", &size);
    
    int arr[size]; // Variable Length Array (VLA) - C99
    
    // Input array elements
    printf("Enter %d elements:\n", size);
    for (int i = 0; i < size; i++) {
        scanf("%d", &arr[i]);
    }
    
    // Output array elements
    printf("Array elements: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    return 0;
}
```

## Multi-dimensional Arrays

### Two-dimensional Arrays
```c
#include <stdio.h>

void print2DArray(int rows, int cols, int arr[rows][cols]) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%3d ", arr[i][j]);
        }
        printf("\n");
    }
}

int main() {
    // 2D array declaration and initialization
    int matrix[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    
    printf("2D Array:\n");
    print2DArray(3, 4, matrix);
    
    // Accessing elements
    printf("Element at [1][2]: %d\n", matrix[1][2]);
    
    // Modifying elements
    matrix[0][0] = 100;
    printf("After modification:\n");
    print2DArray(3, 4, matrix);
    
    return 0;
}
```

### Three-dimensional Arrays
```c
#include <stdio.h>

int main() {
    // 3D array: [depth][rows][cols]
    int cube[2][3][4] = {
        {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}},
        {{13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24}}
    };
    
    // Traversing 3D array
    for (int d = 0; d < 2; d++) {
        printf("Layer %d:\n", d);
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 4; j++) {
                printf("%3d ", cube[d][i][j]);
            }
            printf("\n");
        }
        printf("\n");
    }
    
    return 0;
}
```

### Matrix Operations
```c
#include <stdio.h>

#define ROWS 3
#define COLS 3

void addMatrices(int a[ROWS][COLS], int b[ROWS][COLS], int result[ROWS][COLS]) {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            result[i][j] = a[i][j] + b[i][j];
        }
    }
}

void multiplyMatrices(int a[ROWS][COLS], int b[ROWS][COLS], int result[ROWS][COLS]) {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            result[i][j] = 0;
            for (int k = 0; k < COLS; k++) {
                result[i][j] += a[i][k] * b[k][j];
            }
        }
    }
}

void printMatrix(int matrix[ROWS][COLS]) {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            printf("%4d ", matrix[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}

int main() {
    int a[ROWS][COLS] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    int b[ROWS][COLS] = {{9, 8, 7}, {6, 5, 4}, {3, 2, 1}};
    int sum[ROWS][COLS], product[ROWS][COLS];
    
    addMatrices(a, b, sum);
    multiplyMatrices(a, b, product);
    
    printf("Matrix A:\n");
    printMatrix(a);
    
    printf("Matrix B:\n");
    printMatrix(b);
    
    printf("Sum (A + B):\n");
    printMatrix(sum);
    
    printf("Product (A * B):\n");
    printMatrix(product);
    
    return 0;
}
```

## Dynamic Arrays

### Using malloc and free
```c
#include <stdio.h>
#include <stdlib.h>

int* createArray(int size, int initialValue) {
    int* arr = (int*)malloc(size * sizeof(int));
    if (arr == NULL) {
        printf("Memory allocation failed!\n");
        return NULL;
    }
    
    for (int i = 0; i < size; i++) {
        arr[i] = initialValue;
    }
    
    return arr;
}

int* resizeArray(int* arr, int oldSize, int newSize) {
    int* newArr = (int*)realloc(arr, newSize * sizeof(int));
    if (newArr == NULL) {
        printf("Memory reallocation failed!\n");
        return arr; // Return original array
    }
    
    // Initialize new elements if array expanded
    for (int i = oldSize; i < newSize; i++) {
        newArr[i] = 0;
    }
    
    return newArr;
}

int main() {
    int size = 5;
    
    // Create dynamic array
    int* dynamicArr = createArray(size, 10);
    if (dynamicArr == NULL) return 1;
    
    printf("Initial array: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", dynamicArr[i]);
    }
    printf("\n");
    
    // Resize array
    int newSize = 8;
    dynamicArr = resizeArray(dynamicArr, size, newSize);
    
    printf("Resized array: ");
    for (int i = 0; i < newSize; i++) {
        printf("%d ", dynamicArr[i]);
    }
    printf("\n");
    
    // Don't forget to free memory
    free(dynamicArr);
    
    return 0;
}
```

### Dynamic 2D Arrays
```c
#include <stdio.h>
#include <stdlib.h>

int** create2DArray(int rows, int cols) {
    int** arr = (int**)malloc(rows * sizeof(int*));
    if (arr == NULL) return NULL;
    
    for (int i = 0; i < rows; i++) {
        arr[i] = (int*)malloc(cols * sizeof(int));
        if (arr[i] == NULL) {
            // Free previously allocated memory on failure
            for (int j = 0; j < i; j++) {
                free(arr[j]);
            }
            free(arr);
            return NULL;
        }
    }
    
    return arr;
}

void free2DArray(int** arr, int rows) {
    for (int i = 0; i < rows; i++) {
        free(arr[i]);
    }
    free(arr);
}

int main() {
    int rows = 3, cols = 4;
    
    int** matrix = create2DArray(rows, cols);
    if (matrix == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }
    
    // Initialize matrix
    int value = 1;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            matrix[i][j] = value++;
        }
    }
    
    // Print matrix
    printf("Dynamic 2D Array:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%3d ", matrix[i][j]);
        }
        printf("\n");
    }
    
    free2DArray(matrix, rows);
    
    return 0;
}
```

## Array Algorithms

### Searching Algorithms

#### Linear Search
```c
#include <stdio.h>

int linearSearch(int arr[], int size, int target) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == target) {
            return i; // Return index if found
        }
    }
    return -1; // Return -1 if not found
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int size = sizeof(arr) / sizeof(arr[0]);
    int target = 22;
    
    int result = linearSearch(arr, size, target);
    
    if (result != -1) {
        printf("Element %d found at index %d\n", target, result);
    } else {
        printf("Element %d not found\n", target);
    }
    
    return 0;
}
```

#### Binary Search
```c
#include <stdio.h>

int binarySearch(int arr[], int left, int right, int target) {
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        }
        
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

// Recursive binary search
int binarySearchRecursive(int arr[], int left, int right, int target) {
    if (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        }
        
        if (arr[mid] > target) {
            return binarySearchRecursive(arr, left, mid - 1, target);
        } else {
            return binarySearchRecursive(arr, mid + 1, right, target);
        }
    }
    
    return -1;
}

int main() {
    int arr[] = {2, 3, 4, 10, 40, 50, 60, 70}; // Must be sorted
    int size = sizeof(arr) / sizeof(arr[0]);
    int target = 10;
    
    int result = binarySearch(arr, 0, size - 1, target);
    
    if (result != -1) {
        printf("Element %d found at index %d\n", target, result);
    } else {
        printf("Element %d not found\n", target);
    }
    
    return 0;
}
```

### Sorting Algorithms

#### Bubble Sort
```c
#include <stdio.h>

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int swapped = 0;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap elements
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = 1;
            }
        }
        // If no swapping occurred, array is sorted
        if (swapped == 0) break;
    }
}

void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    printf("Original array: ");
    printArray(arr, n);
    
    bubbleSort(arr, n);
    
    printf("Sorted array: ");
    printArray(arr, n);
    
    return 0;
}
```

#### Quick Sort
```c
#include <stdio.h>

void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high]; // Choose last element as pivot
    int i = (low - 1);     // Index of smaller element
    
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    printf("Original array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
    
    quickSort(arr, 0, n - 1);
    
    printf("Sorted array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
    
    return 0;
}
```

### Array Manipulation Operations

#### Array Rotation
```c
#include <stdio.h>

void rotateLeft(int arr[], int n, int d) {
    d = d % n; // Handle cases where d > n
    
    // Store first d elements in temp array
    int temp[d];
    for (int i = 0; i < d; i++) {
        temp[i] = arr[i];
    }
    
    // Shift remaining elements
    for (int i = d; i < n; i++) {
        arr[i - d] = arr[i];
    }
    
    // Copy back temp elements
    for (int i = 0; i < d; i++) {
        arr[n - d + i] = temp[i];
    }
}

void reverseArray(int arr[], int start, int end) {
    while (start < end) {
        int temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;
        start++;
        end--;
    }
}

// Rotation using reversal algorithm
void rotateLeftReversal(int arr[], int n, int d) {
    d = d % n;
    reverseArray(arr, 0, d - 1);
    reverseArray(arr, d, n - 1);
    reverseArray(arr, 0, n - 1);
}

int main() {
    int arr1[] = {1, 2, 3, 4, 5, 6, 7};
    int arr2[] = {1, 2, 3, 4, 5, 6, 7};
    int n = sizeof(arr1) / sizeof(arr1[0]);
    int d = 2; // Rotate left by 2 positions
    
    printf("Original array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr1[i]);
    printf("\n");
    
    rotateLeft(arr1, n, d);
    printf("After left rotation by %d: ", d);
    for (int i = 0; i < n; i++) printf("%d ", arr1[i]);
    printf("\n");
    
    rotateLeftReversal(arr2, n, d);
    printf("Using reversal algorithm: ");
    for (int i = 0; i < n; i++) printf("%d ", arr2[i]);
    printf("\n");
    
    return 0;
}
```

#### Finding Maximum and Minimum
```c
#include <stdio.h>
#include <limits.h>

typedef struct {
    int min;
    int max;
} MinMax;

MinMax findMinMax(int arr[], int n) {
    MinMax result;
    
    if (n == 0) {
        result.min = result.max = INT_MAX;
        return result;
    }
    
    result.min = result.max = arr[0];
    
    for (int i = 1; i < n; i++) {
        if (arr[i] < result.min) {
            result.min = arr[i];
        }
        if (arr[i] > result.max) {
            result.max = arr[i];
        }
    }
    
    return result;
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    MinMax result = findMinMax(arr, n);
    
    printf("Array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
    
    printf("Minimum element: %d\n", result.min);
    printf("Maximum element: %d\n", result.max);
    
    return 0;
}
```

## Memory Layout and Performance

### Cache-Friendly Array Access
```c
#include <stdio.h>
#include <time.h>

#define ROWS 1000
#define COLS 1000

void rowMajorAccess(int matrix[ROWS][COLS]) {
    // Cache-friendly: accessing elements in the order they are stored
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            matrix[i][j] = i * j;
        }
    }
}

void columnMajorAccess(int matrix[ROWS][COLS]) {
    // Cache-unfriendly: jumping between distant memory locations
    for (int j = 0; j < COLS; j++) {
        for (int i = 0; i < ROWS; i++) {
            matrix[i][j] = i * j;
        }
    }
}

int main() {
    static int matrix[ROWS][COLS]; // Use static to avoid stack overflow
    
    clock_t start, end;
    
    // Measure row-major access time
    start = clock();
    rowMajorAccess(matrix);
    end = clock();
    double rowTime = ((double)(end - start)) / CLOCKS_PER_SEC;
    
    // Measure column-major access time
    start = clock();
    columnMajorAccess(matrix);
    end = clock();
    double colTime = ((double)(end - start)) / CLOCKS_PER_SEC;
    
    printf("Row-major access time: %f seconds\n", rowTime);
    printf("Column-major access time: %f seconds\n", colTime);
    printf("Performance ratio: %.2fx\n", colTime / rowTime);
    
    return 0;
}
```

### Array vs Pointer Arithmetic
```c
#include <stdio.h>

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int *ptr = arr;
    
    printf("Array access methods:\n");
    
    // Method 1: Array indexing
    printf("arr[2] = %d\n", arr[2]);
    
    // Method 2: Pointer arithmetic
    printf("*(arr + 2) = %d\n", *(arr + 2));
    printf("*(ptr + 2) = %d\n", *(ptr + 2));
    printf("ptr[2] = %d\n", ptr[2]);
    
    // Address arithmetic
    printf("\nMemory addresses:\n");
    for (int i = 0; i < 5; i++) {
        printf("arr[%d] address: %p, value: %d\n", 
               i, (void*)&arr[i], arr[i]);
    }
    
    // Pointer increment
    printf("\nPointer traversal:\n");
    ptr = arr;
    for (int i = 0; i < 5; i++) {
        printf("*ptr = %d, address: %p\n", *ptr, (void*)ptr);
        ptr++;
    }
    
    return 0;
}
```

## Common Pitfalls and Best Practices

### Array Bounds Checking
```c
#include <stdio.h>
#include <stdbool.h>

bool safeArrayAccess(int arr[], int size, int index, int* value) {
    if (index < 0 || index >= size) {
        printf("Error: Index %d out of bounds [0, %d]\n", index, size - 1);
        return false;
    }
    *value = arr[index];
    return true;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int size = sizeof(arr) / sizeof(arr[0]);
    int value;
    
    // Safe access
    if (safeArrayAccess(arr, size, 2, &value)) {
        printf("arr[2] = %d\n", value);
    }
    
    // Attempting unsafe access
    if (!safeArrayAccess(arr, size, 10, &value)) {
        printf("Access denied for safety\n");
    }
    
    return 0;
}
```

### Array Parameter Passing
```c
#include <stdio.h>

// Arrays are passed by reference (address of first element)
void modifyArray(int arr[], int size) {
    printf("Inside function - sizeof(arr): %lu\n", sizeof(arr)); // Size of pointer
    for (int i = 0; i < size; i++) {
        arr[i] *= 2;
    }
}

// Using const to prevent modification
void printArray(const int arr[], int size) {
    // arr[0] = 100; // This would cause compilation error
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// Alternative syntax using pointer notation
void modifyArrayPtr(int *arr, int size) {
    for (int i = 0; i < size; i++) {
        *(arr + i) += 10;
    }
}

int main() {
    int numbers[] = {1, 2, 3, 4, 5};
    int size = sizeof(numbers) / sizeof(numbers[0]);
    
    printf("Original array: ");
    printArray(numbers, size);
    
    printf("Main function - sizeof(numbers): %lu\n", sizeof(numbers));
    
    modifyArray(numbers, size);
    printf("After modifyArray: ");
    printArray(numbers, size);
    
    modifyArrayPtr(numbers, size);
    printf("After modifyArrayPtr: ");
    printArray(numbers, size);
    
    return 0;
}
```

### Memory Management Best Practices
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Safe string copy function
char* safeStringCopy(const char* source) {
    if (source == NULL) return NULL;
    
    size_t len = strlen(source);
    char* copy = malloc((len + 1) * sizeof(char));
    
    if (copy == NULL) {
        printf("Memory allocation failed!\n");
        return NULL;
    }
    
    strcpy(copy, source);
    return copy;
}

// Safe array copy function
int* safeArrayCopy(const int* source, int size) {
    if (source == NULL || size <= 0) return NULL;
    
    int* copy = malloc(size * sizeof(int));
    if (copy == NULL) {
        printf("Memory allocation failed!\n");
        return NULL;
    }
    
    memcpy(copy, source, size * sizeof(int));
    return copy;
}

int main() {
    int original[] = {1, 2, 3, 4, 5};
    int size = 5;
    
    // Create a copy
    int* copy = safeArrayCopy(original, size);
    if (copy != NULL) {
        printf("Original: ");
        for (int i = 0; i < size; i++) printf("%d ", original[i]);
        printf("\n");
        
        printf("Copy: ");
        for (int i = 0; i < size; i++) printf("%d ", copy[i]);
        printf("\n");
        
        // Modify copy to show independence
        copy[0] = 100;
        printf("After modifying copy[0]:\n");
        printf("Original[0]: %d, Copy[0]: %d\n", original[0], copy[0]);
        
        free(copy); // Don't forget to free allocated memory
    }
    
    return 0;
}
```

## Advanced Topics

### Function Pointers with Arrays
```c
#include <stdio.h>

// Function pointer type for array operations
typedef void (*ArrayOperation)(int[], int);

void printArrayFunc(int arr[], int size) {
    printf("Array: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

void doubleElements(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        arr[i] *= 2;
    }
}

void squareElements(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        arr[i] *= arr[i];
    }
}

void applyOperation(int arr[], int size, ArrayOperation op) {
    op(arr, size);
}

int main() {
    int numbers[] = {1, 2, 3, 4, 5};
    int size = sizeof(numbers) / sizeof(numbers[0]);
    
    ArrayOperation operations[] = {printArrayFunc, doubleElements, squareElements};
    
    printf("Original: ");
    operations[0](numbers, size); // Print
    
    printf("After doubling: ");
    applyOperation(numbers, size, operations[1]); // Double
    operations[0](numbers, size); // Print
    
    printf("After squaring: ");
    applyOperation(numbers, size, operations[2]); // Square
    operations[0](