# Mixins

## Table of Contents
1. [Introduction to Mixins](#introduction-to-mixins)
2. [Basic Mixin Syntax](#basic-mixin-syntax)
3. [Mixin Constraints](#mixin-constraints)
4. [Multiple Mixins](#multiple-mixins)
5. [Mixin Order and Linearization](#mixin-order-and-linearization)
6. [The `on` Keyword](#the-on-keyword)
7. [Mixins vs Inheritance](#mixins-vs-inheritance)
8. [Abstract Members in Mixins](#abstract-members-in-mixins)
9. [Constructor Limitations](#constructor-limitations)
10. [Mixin Application](#mixin-application)
11. [Best Practices](#best-practices)
12. [Common Use Cases](#common-use-cases)
13. [Advanced Patterns](#advanced-patterns)

---

## Introduction to Mixins

Mixins are a way of reusing a class's code in multiple class hierarchies. They allow you to add functionality to classes without using traditional inheritance. In Dart, mixins provide a powerful mechanism for code reuse that complements single inheritance.

**Key characteristics:**
- Mixins allow horizontal code reuse across unrelated class hierarchies
- A class can use multiple mixins (but can only extend one class)
- Mixins cannot be instantiated directly
- Mixins don't have constructors

---

## Basic Mixin Syntax

### Defining a Mixin

```dart
mixin Musical {
  bool canPlayPiano = false;
  bool canPlayGuitar = false;
  
  void playPiano() {
    print('Playing piano');
  }
  
  void playGuitar() {
    print('Playing guitar');
  }
}
```

### Using a Mixin

```dart
class Performer with Musical {
  String name;
  
  Performer(this.name);
}

void main() {
  var performer = Performer('John');
  performer.playPiano(); // Output: Playing piano
  performer.canPlayPiano = true;
}
```

### Class as Mixin

Before Dart 2.1, you could use regular classes as mixins. This is still possible if the class meets certain criteria:

```dart
class Musical {
  void playMusic() {
    print('Playing music');
  }
}

// Using a class as a mixin
class Performer with Musical {}
```

**Requirements for using a class as a mixin:**
- The class must not declare any constructors
- The class must not call `super` (except for Object)
- The class must extend only Object

---

## Mixin Constraints

### The `on` Keyword

You can restrict which classes can use a mixin by specifying a superclass constraint using the `on` keyword:

```dart
class Musician {
  String? instrument;
}

mixin MusicalPerformer on Musician {
  void perform() {
    print('Performing with $instrument');
  }
}

// This works - Guitarist extends Musician
class Guitarist extends Musician with MusicalPerformer {
  Guitarist() {
    instrument = 'Guitar';
  }
}

// This would cause an error - Dancer doesn't extend Musician
// class Dancer with MusicalPerformer {} // ERROR!
```

### Multiple Constraints

A mixin can require multiple superclass constraints:

```dart
class Musician {
  void playInstrument() {}
}

class Dancer {
  void dance() {}
}

mixin Performer on Musician, Dancer {
  void performShow() {
    playInstrument();
    dance();
  }
}

// Must extend a class that has both Musician and Dancer
class MusicalDancer extends Musician with Dancer {}
class ShowPerformer extends MusicalDancer with Performer {}
```

---

## Multiple Mixins

A class can use multiple mixins by listing them with commas:

```dart
mixin Walker {
  void walk() => print('Walking');
}

mixin Swimmer {
  void swim() => print('Swimming');
}

mixin Flyer {
  void fly() => print('Flying');
}

class Duck with Walker, Swimmer, Flyer {
  String name = 'Donald';
}

void main() {
  var duck = Duck();
  duck.walk();  // Walking
  duck.swim();  // Swimming
  duck.fly();   // Flying
}
```

---

## Mixin Order and Linearization

The order in which mixins are applied matters. Dart uses a linearization algorithm to determine the order of method resolution.

```dart
mixin A {
  void method() => print('A');
}

mixin B {
  void method() => print('B');
}

mixin C {
  void method() => print('C');
}

class MyClass with A, B, C {}

void main() {
  MyClass().method(); // Output: C
  // The last mixin (rightmost) takes precedence
}
```

### Method Resolution Order (MRO)

```dart
class Animal {
  void makeSound() => print('Some sound');
}

mixin CanBark {
  void makeSound() => print('Bark');
}

mixin CanMeow {
  void makeSound() => print('Meow');
}

class Dog extends Animal with CanBark, CanMeow {}

void main() {
  Dog().makeSound(); // Output: Meow
  // CanMeow is applied last, so it overrides CanBark
}
```

### Using `super` in Mixins

Mixins can call `super` to invoke the next method in the chain:

```dart
class Animal {
  void makeSound() => print('Animal sound');
}

mixin Loud {
  void makeSound() {
    print('LOUD: ');
    super.makeSound();
  }
}

mixin Quiet {
  void makeSound() {
    print('Quiet: ');
    super.makeSound();
  }
}

class Dog extends Animal with Loud, Quiet {}

void main() {
  Dog().makeSound();
  // Output:
  // Quiet: 
  // LOUD: 
  // Animal sound
}
```

---

## The `on` Keyword

### Accessing Superclass Members

The `on` keyword allows mixins to access members of the required superclass:

```dart
abstract class Vehicle {
  int get wheels;
  void drive();
}

mixin Electric on Vehicle {
  double batteryLevel = 100.0;
  
  void chargeBattery() {
    batteryLevel = 100.0;
    print('Battery charged for $wheels-wheeled vehicle');
  }
  
  void electricDrive() {
    if (batteryLevel > 0) {
      drive(); // Can call superclass method
      batteryLevel -= 10;
    }
  }
}

class Car extends Vehicle {
  @override
  int get wheels => 4;
  
  @override
  void drive() => print('Driving car');
}

class ElectricCar extends Car with Electric {}
```

---

## Mixins vs Inheritance

### When to Use Mixins

**Use mixins when:**
- You want to share behavior across unrelated class hierarchies
- You need multiple inheritance-like functionality
- The behavior is orthogonal to the class hierarchy
- You want to compose behaviors

**Use inheritance when:**
- There's a clear "is-a" relationship
- You need constructor chaining
- You want to represent specialization

### Comparison Example

```dart
// Inheritance approach
abstract class Animal {
  void eat() => print('Eating');
}

class Dog extends Animal {
  void bark() => print('Bark');
}

// Mixin approach for cross-cutting concerns
mixin Trainable {
  List<String> tricks = [];
  
  void learn(String trick) {
    tricks.add(trick);
    print('Learned: $trick');
  }
}

mixin Friendly {
  void greet() => print('Hello!');
}

class ServiceDog extends Dog with Trainable, Friendly {}
```

---

## Abstract Members in Mixins

Mixins can declare abstract members that must be implemented by the class using the mixin:

```dart
mixin Validator {
  // Abstract method
  bool validate();
  
  void checkValidity() {
    if (validate()) {
      print('Valid');
    } else {
      print('Invalid');
    }
  }
}

class EmailValidator with Validator {
  String email;
  
  EmailValidator(this.email);
  
  @override
  bool validate() {
    return email.contains('@');
  }
}

void main() {
  var validator = EmailValidator('test@example.com');
  validator.checkValidity(); // Output: Valid
}
```

---

## Constructor Limitations

Mixins cannot have constructors. If you need initialization logic, use methods or require initialization through the class:

```dart
mixin Logger {
  String? logPrefix;
  
  // Instead of constructor, use initialization method
  void initLogger(String prefix) {
    logPrefix = prefix;
  }
  
  void log(String message) {
    print('[$logPrefix] $message');
  }
}

class Service with Logger {
  Service(String name) {
    initLogger(name);
  }
}

void main() {
  var service = Service('API');
  service.log('Started'); // Output: [API] Started
}
```

---

## Mixin Application

### Basic Application Pattern

```dart
class Base {
  void baseMethod() => print('Base');
}

mixin M1 {
  void m1Method() => print('M1');
}

mixin M2 {
  void m2Method() => print('M2');
}

// Apply mixins to a base class
class Combined extends Base with M1, M2 {}

// Or create a mixin application class
class BaseWithM1 = Base with M1;
class BaseWithBoth = Base with M1, M2;
```

### Type Relationships

```dart
mixin Flyable {
  void fly() => print('Flying');
}

class Bird {}
class FlyingBird extends Bird with Flyable {}

void main() {
  var bird = FlyingBird();
  
  // Type checks
  print(bird is Bird);     // true
  print(bird is Flyable);  // true
  print(bird is FlyingBird); // true
}
```

---

## Best Practices

### 1. Name Mixins Descriptively

Use adjectives or capability names:

```dart
// Good
mixin Serializable {}
mixin Comparable {}
mixin Loggable {}

// Less clear
mixin Data {}
mixin Helper {}
```

### 2. Keep Mixins Focused

Each mixin should have a single, clear purpose:

```dart
// Good - focused mixin
mixin JsonSerializable {
  Map<String, dynamic> toJson();
  void fromJson(Map<String, dynamic> json);
}

// Poor - too many responsibilities
mixin DataHandler {
  void saveToDatabase() {}
  void sendToApi() {}
  void cacheLocally() {}
  void validateData() {}
}
```

### 3. Use Constraints Appropriately

```dart
// Good - constraint ensures required interface
abstract class Identifiable {
  String get id;
}

mixin Trackable on Identifiable {
  DateTime? lastSeen;
  
  void track() {
    print('Tracking $id');
    lastSeen = DateTime.now();
  }
}
```

### 4. Avoid State in Mixins When Possible

Prefer stateless mixins that operate on the class's state:

```dart
// Good - stateless utility
mixin StringHelpers {
  String capitalize(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1);
  }
}

// Use cautiously - stateful mixin
mixin Counter {
  int _count = 0;
  int get count => _count;
  void increment() => _count++;
}
```

---

## Common Use Cases

### 1. Providing Common Functionality

```dart
mixin Timestamp {
  DateTime? createdAt;
  DateTime? updatedAt;
  
  void markCreated() {
    createdAt = DateTime.now();
  }
  
  void markUpdated() {
    updatedAt = DateTime.now();
  }
}

class User with Timestamp {
  String name;
  User(this.name) {
    markCreated();
  }
}
```

### 2. Implementing Equality and Hashing

```dart
mixin EquatableById {
  int get id;
  
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EquatableById && 
      runtimeType == other.runtimeType &&
      id == other.id;
  
  @override
  int get hashCode => id.hashCode;
}

class Product with EquatableById {
  @override
  final int id;
  String name;
  
  Product(this.id, this.name);
}
```

### 3. State Management

```dart
mixin LoadingState {
  bool _isLoading = false;
  String? _error;
  
  bool get isLoading => _isLoading;
  String? get error => _error;
  bool get hasError => _error != null;
  
  void startLoading() {
    _isLoading = true;
    _error = null;
  }
  
  void stopLoading() {
    _isLoading = false;
  }
  
  void setError(String error) {
    _error = error;
    _isLoading = false;
  }
}

class DataService with LoadingState {
  Future<void> fetchData() async {
    startLoading();
    try {
      // Fetch data
      await Future.delayed(Duration(seconds: 2));
      stopLoading();
    } catch (e) {
      setError(e.toString());
    }
  }
}
```

### 4. Validation

```dart
mixin ValidationMixin {
  Map<String, String> _errors = {};
  
  bool get isValid => _errors.isEmpty;
  Map<String, String> get errors => Map.unmodifiable(_errors);
  
  void addError(String field, String message) {
    _errors[field] = message;
  }
  
  void clearErrors() {
    _errors.clear();
  }
  
  void clearError(String field) {
    _errors.remove(field);
  }
}

class RegistrationForm with ValidationMixin {
  String email = '';
  String password = '';
  
  void validate() {
    clearErrors();
    
    if (email.isEmpty || !email.contains('@')) {
      addError('email', 'Invalid email');
    }
    
    if (password.length < 8) {
      addError('password', 'Password too short');
    }
  }
}
```

### 5. Disposable Pattern

```dart
mixin Disposable {
  bool _disposed = false;
  
  bool get isDisposed => _disposed;
  
  void dispose() {
    if (_disposed) return;
    _disposed = true;
    onDispose();
  }
  
  void onDispose();
  
  void checkDisposed() {
    if (_disposed) {
      throw StateError('Object has been disposed');
    }
  }
}

class Connection with Disposable {
  void sendData(String data) {
    checkDisposed();
    print('Sending: $data');
  }
  
  @override
  void onDispose() {
    print('Closing connection');
  }
}
```

---

## Advanced Patterns

### 1. Mixin Composition

```dart
mixin ReadOperation {
  Future<Map<String, dynamic>> read(String id);
}

mixin WriteOperation {
  Future<void> write(String id, Map<String, dynamic> data);
}

mixin DeleteOperation {
  Future<void> delete(String id);
}

// Compose multiple mixins for CRUD operations
abstract class CrudService with ReadOperation, WriteOperation, DeleteOperation {
  String get collectionName;
}

class UserService extends CrudService {
  @override
  String get collectionName => 'users';
  
  @override
  Future<Map<String, dynamic>> read(String id) async {
    // Implementation
    return {'id': id, 'name': 'User'};
  }
  
  @override
  Future<void> write(String id, Map<String, dynamic> data) async {
    // Implementation
  }
  
  @override
  Future<void> delete(String id) async {
    // Implementation
  }
}
```

### 2. Template Method Pattern

```dart
mixin DataProcessor {
  Future<void> process(dynamic data) async {
    await beforeProcess();
    await doProcess(data);
    await afterProcess();
  }
  
  Future<void> beforeProcess() async {
    print('Preparing to process');
  }
  
  Future<void> doProcess(dynamic data);
  
  Future<void> afterProcess() async {
    print('Processing complete');
  }
}

class ImageProcessor with DataProcessor {
  @override
  Future<void> doProcess(dynamic data) async {
    print('Processing image: $data');
    await Future.delayed(Duration(seconds: 1));
  }
}
```

### 3. Capability-Based Design

```dart
mixin Sortable<T> {
  List<T> get items;
  
  void sort([int Function(T, T)? compare]) {
    items.sort(compare);
  }
}

mixin Filterable<T> {
  List<T> get items;
  
  List<T> filter(bool Function(T) predicate) {
    return items.where(predicate).toList();
  }
}

mixin Pageable<T> {
  List<T> get items;
  
  List<T> paginate(int page, int pageSize) {
    int start = page * pageSize;
    int end = start + pageSize;
    return items.sublist(
      start,
      end > items.length ? items.length : end,
    );
  }
}

class DataCollection<T> with Sortable<T>, Filterable<T>, Pageable<T> {
  @override
  final List<T> items;
  
  DataCollection(this.items);
}

void main() {
  var numbers = DataCollection<int>([5, 2, 8, 1, 9, 3]);
  
  numbers.sort();
  print(numbers.items); // [1, 2, 3, 5, 8, 9]
  
  var evens = numbers.filter((n) => n % 2 == 0);
  print(evens); // [2, 8]
  
  var page = numbers.paginate(0, 3);
  print(page); // [1, 2, 3]
}
```

### 4. Observer Pattern with Mixins

```dart
mixin Observable<T> {
  final List<void Function(T)> _listeners = [];
  
  void addListener(void Function(T) listener) {
    _listeners.add(listener);
  }
  
  void removeListener(void Function(T) listener) {
    _listeners.remove(listener);
  }
  
  void notifyListeners(T data) {
    for (var listener in _listeners) {
      listener(data);
    }
  }
}

class Counter with Observable<int> {
  int _count = 0;
  
  int get count => _count;
  
  void increment() {
    _count++;
    notifyListeners(_count);
  }
}

void main() {
  var counter = Counter();
  
  counter.addListener((count) {
    print('Count changed to: $count');
  });
  
  counter.increment(); // Output: Count changed to: 1
  counter.increment(); // Output: Count changed to: 2
}
```

### 5. Caching Mixin

```dart
mixin Cacheable<K, V> {
  final Map<K, V> _cache = {};
  
  V? getCached(K key) => _cache[key];
  
  void cache(K key, V value) {
    _cache[key] = value;
  }
  
  void clearCache() {
    _cache.clear();
  }
  
  Future<V> getOrCache(K key, Future<V> Function() fetcher) async {
    if (_cache.containsKey(key)) {
      return _cache[key]!;
    }
    
    final value = await fetcher();
    cache(key, value);
    return value;
  }
}

class ApiService with Cacheable<String, Map<String, dynamic>> {
  Future<Map<String, dynamic>> getUser(String id) async {
    return getOrCache(id, () async {
      print('Fetching user $id from API');
      await Future.delayed(Duration(seconds: 1));
      return {'id': id, 'name': 'User $id'};
    });
  }
}

void main() async {
  var service = ApiService();
  
  await service.getUser('123'); // Fetches from API
  await service.getUser('123'); // Returns from cache
}
```

---

## Summary

Mixins in Dart provide a powerful and flexible way to share code across class hierarchies. Key takeaways:

- **Use mixins for horizontal code reuse** across unrelated classes
- **Apply multiple mixins** to compose functionality
- **Use the `on` keyword** to constrain which classes can use a mixin
- **Order matters** - the rightmost mixin takes precedence in method resolution
- **Mixins cannot have constructors** but can have initialization methods
- **Best used for cross-cutting concerns** like logging, validation, and state management
- **Keep mixins focused** on a single responsibility
- **Combine with inheritance** for powerful class designs

Mixins are an essential tool in Dart's object-oriented programming toolkit, enabling clean, reusable, and composable code designs.

---

## Additional Resources

- [Official Dart Language Tour - Mixins](https://dart.dev/language/mixins)
- [Effective Dart](https://dart.dev/guides/language/effective-dart)
- [Dart API Documentation](https://api.dart.dev/)

---

*Last Updated: November 2025*