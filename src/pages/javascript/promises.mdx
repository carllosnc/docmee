---
layout: ../../layout/main-layout.astro
---
<a href="/javascript">← Javascript</a> <br /> <br />

# Promises

## Table of Contents
1. [Introduction](#introduction)
2. [Promise States](#promise-states)
3. [Creating Promises](#creating-promises)
4. [Consuming Promises](#consuming-promises)
5. [Promise Methods](#promise-methods)
6. [Error Handling](#error-handling)
7. [Promise Chaining](#promise-chaining)
8. [Static Methods](#static-methods)
9. [Common Patterns](#common-patterns)
10. [Best Practices](#best-practices)

## Introduction

A Promise is an object representing the eventual completion or failure of an asynchronous operation. It serves as a placeholder for a value that may not be available yet but will be resolved at some point in the future.

Promises provide a cleaner alternative to callback-based asynchronous code, helping avoid "callback hell" and making error handling more straightforward.

## Promise States

A Promise exists in one of three states:

- **Pending**: Initial state, neither fulfilled nor rejected
- **Fulfilled**: The operation completed successfully
- **Rejected**: The operation failed

Once a promise is fulfilled or rejected, it becomes **settled** and cannot change states again.

## Creating Promises

### Basic Promise Constructor

```javascript
const myPromise = new Promise((resolve, reject) => {
  // Asynchronous operation
  const success = true;

  if (success) {
    resolve('Operation successful!');
  } else {
    reject('Operation failed!');
  }
});
```

### Real-World Example

```javascript
function fetchUserData(userId) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (userId > 0) {
        resolve({ id: userId, name: 'John Doe' });
      } else {
        reject(new Error('Invalid user ID'));
      }
    }, 1000);
  });
}
```

## Consuming Promises

### Using .then()

The `then()` method takes two optional arguments: callbacks for the fulfilled and rejected cases.

```javascript
myPromise
  .then(
    result => console.log(result),  // Success handler
    error => console.error(error)    // Error handler (optional)
  );
```

### Using .catch()

The `catch()` method handles rejections and is typically chained after `then()`.

```javascript
myPromise
  .then(result => console.log(result))
  .catch(error => console.error(error));
```

### Using .finally()

The `finally()` method executes regardless of whether the promise was fulfilled or rejected.

```javascript
myPromise
  .then(result => console.log(result))
  .catch(error => console.error(error))
  .finally(() => console.log('Cleanup operations'));
```

## Promise Methods

### Instance Methods

#### .then(onFulfilled, onRejected)

```javascript
promise.then(
  value => {
    // Handle success
    return value * 2;
  },
  error => {
    // Handle error (optional)
    return 0;
  }
);
```

#### .catch(onRejected)

```javascript
promise.catch(error => {
  // Handle error
  console.error('Error:', error);
});
```

#### .finally(onFinally)

```javascript
promise.finally(() => {
  // Cleanup code
  console.log('Promise settled');
});
```

## Error Handling

### Catching Errors in Chains

```javascript
fetchUserData(1)
  .then(user => fetchUserPosts(user.id))
  .then(posts => displayPosts(posts))
  .catch(error => {
    // Catches errors from any step in the chain
    console.error('Something went wrong:', error);
  });
```

### Throwing Errors in Promises

```javascript
new Promise((resolve, reject) => {
  throw new Error('Immediate error');
  // Equivalent to: reject(new Error('Immediate error'));
});
```

### Rethrowing Errors

```javascript
promise
  .catch(error => {
    console.error('Logging error:', error);
    throw error; // Rethrow for further handling
  })
  .catch(error => {
    console.error('Final handler:', error);
  });
```

## Promise Chaining

Promises can be chained to perform sequential asynchronous operations.

### Basic Chaining

```javascript
fetchUserData(1)
  .then(user => {
    console.log('User:', user);
    return fetchUserPosts(user.id);
  })
  .then(posts => {
    console.log('Posts:', posts);
    return posts.length;
  })
  .then(count => {
    console.log('Post count:', count);
  })
  .catch(error => console.error(error));
```

### Returning Promises in Chains

```javascript
function getUserWithPosts(userId) {
  let userData;

  return fetchUserData(userId)
    .then(user => {
      userData = user;
      return fetchUserPosts(user.id);
    })
    .then(posts => {
      return { ...userData, posts };
    });
}
```

## Static Methods

### Promise.resolve()

Creates a promise that is immediately resolved with a given value.

```javascript
Promise.resolve(42)
  .then(value => console.log(value)); // 42

// Wrapping a value
const promise = Promise.resolve('Hello');
```

### Promise.reject()

Creates a promise that is immediately rejected with a given reason.

```javascript
Promise.reject(new Error('Failed'))
  .catch(error => console.error(error));
```

### Promise.all()

Waits for all promises to fulfill, or rejects if any promise rejects.

```javascript
const promise1 = Promise.resolve(3);
const promise2 = new Promise(resolve => setTimeout(() => resolve(42), 100));
const promise3 = Promise.resolve('foo');

Promise.all([promise1, promise2, promise3])
  .then(values => {
    console.log(values); // [3, 42, 'foo']
  })
  .catch(error => {
    console.error('One or more promises failed:', error);
  });
```

### Promise.allSettled()

Waits for all promises to settle (either fulfill or reject).

```javascript
const promises = [
  Promise.resolve(1),
  Promise.reject('error'),
  Promise.resolve(3)
];

Promise.allSettled(promises)
  .then(results => {
    results.forEach(result => {
      if (result.status === 'fulfilled') {
        console.log('Value:', result.value);
      } else {
        console.log('Reason:', result.reason);
      }
    });
  });
```

### Promise.race()

Returns a promise that fulfills or rejects as soon as one of the promises fulfills or rejects.

```javascript
const promise1 = new Promise(resolve => setTimeout(() => resolve('one'), 500));
const promise2 = new Promise(resolve => setTimeout(() => resolve('two'), 100));

Promise.race([promise1, promise2])
  .then(value => console.log(value)); // 'two'
```

### Promise.any()

Returns a promise that fulfills when any of the promises fulfills, or rejects if all promises reject.

```javascript
const promises = [
  Promise.reject('Error 1'),
  Promise.resolve('Success'),
  Promise.reject('Error 2')
];

Promise.any(promises)
  .then(value => console.log(value)) // 'Success'
  .catch(error => console.error(error));
```

## Common Patterns

### Promisifying Callback-Based Functions

```javascript
function readFilePromise(filename) {
  return new Promise((resolve, reject) => {
    fs.readFile(filename, 'utf8', (error, data) => {
      if (error) {
        reject(error);
      } else {
        resolve(data);
      }
    });
  });
}
```

### Sequential Execution with Reduce

```javascript
const tasks = [task1, task2, task3];

tasks.reduce((promise, task) => {
  return promise.then(result => {
    return task().then(taskResult => [...result, taskResult]);
  });
}, Promise.resolve([]))
  .then(results => console.log(results));
```

### Parallel Execution with Limited Concurrency

```javascript
async function runWithLimit(tasks, limit) {
  const results = [];
  const executing = [];

  for (const task of tasks) {
    const promise = task().then(result => {
      executing.splice(executing.indexOf(promise), 1);
      return result;
    });

    results.push(promise);
    executing.push(promise);

    if (executing.length >= limit) {
      await Promise.race(executing);
    }
  }

  return Promise.all(results);
}
```

### Timeout Pattern

```javascript
function timeout(promise, ms) {
  return Promise.race([
    promise,
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Timeout')), ms)
    )
  ]);
}

// Usage
timeout(fetchUserData(1), 5000)
  .then(user => console.log(user))
  .catch(error => console.error(error));
```

### Retry Pattern

```javascript
function retry(fn, maxAttempts = 3, delay = 1000) {
  return new Promise((resolve, reject) => {
    function attempt(attemptNumber) {
      fn()
        .then(resolve)
        .catch(error => {
          if (attemptNumber >= maxAttempts) {
            reject(error);
          } else {
            setTimeout(() => attempt(attemptNumber + 1), delay);
          }
        });
    }
    attempt(1);
  });
}
```

## Best Practices

### Always Return Promises in Chains

```javascript
// Good
promise
  .then(result => {
    return processResult(result);
  })
  .then(processed => console.log(processed));

// Bad - breaks the chain
promise
  .then(result => {
    processResult(result); // Missing return
  })
  .then(processed => console.log(processed)); // undefined
```

### Use .catch() for Error Handling

```javascript
// Good
promise
  .then(result => processResult(result))
  .catch(error => handleError(error));

// Avoid - second argument to .then() doesn't catch errors from success handler
promise.then(
  result => processResult(result),
  error => handleError(error)
);
```

### Avoid the Promise Constructor Anti-Pattern

```javascript
// Bad - unnecessary wrapping
function getUserData() {
  return new Promise((resolve, reject) => {
    fetchUserData()
      .then(data => resolve(data))
      .catch(error => reject(error));
  });
}

// Good - just return the promise
function getUserData() {
  return fetchUserData();
}
```

### Handle All Promise Rejections

```javascript
// Always add .catch() or use try-catch with async/await
promise
  .then(result => console.log(result))
  .catch(error => console.error(error));
```

### Don't Mix Callbacks and Promises

```javascript
// Bad - mixing paradigms
function getData(callback) {
  return fetch(url)
    .then(response => response.json())
    .then(data => {
      callback(null, data);
      return data;
    });
}

// Good - use one pattern
function getData() {
  return fetch(url)
    .then(response => response.json());
}
```

### Use Promise.all() for Independent Operations

```javascript
// Good - parallel execution
Promise.all([
  fetchUsers(),
  fetchPosts(),
  fetchComments()
]).then(([users, posts, comments]) => {
  // Process results
});

// Bad - sequential execution when not needed
fetchUsers()
  .then(users => fetchPosts())
  .then(posts => fetchComments())
  .then(comments => {
    // Process results
  });
```

### Consider Using Async/Await

Modern JavaScript offers async/await syntax, which is syntactic sugar over promises and often makes code more readable:

```javascript
// With promises
function processData() {
  return fetchUserData(1)
    .then(user => fetchUserPosts(user.id))
    .then(posts => displayPosts(posts))
    .catch(error => console.error(error));
}

// With async/await
async function processData() {
  try {
    const user = await fetchUserData(1);
    const posts = await fetchUserPosts(user.id);
    displayPosts(posts);
  } catch (error) {
    console.error(error);
  }
}
```

## Summary

Promises are a fundamental part of modern JavaScript, providing a powerful way to handle asynchronous operations. Understanding promises is essential for working with APIs, file operations, timers, and any other asynchronous code. While async/await syntax has made working with promises more convenient, understanding the underlying promise mechanics remains crucial for effective JavaScript development.
