---
layout: ../../layout/main-layout.astro
---
<a href="/javascript">‚Üê Javascript</a> <br /> <br />

# Iterator Protocol

The iterator protocol in JavaScript is a standardized way to define how objects produce a sequence of values. It's a fundamental concept that powers many JavaScript features like `for...of` loops, destructuring, and the spread operator.

## Table of Contents

- [Core Concepts](#core-concepts)
- [Basic Iterator Example](#basic-iterator-example)
- [Creating Iterables](#creating-iterables)
- [Built-in Iterables](#built-in-iterables)
- [Generator Functions](#generator-functions)
- [Practical Applications](#practical-applications)
- [Using with Modern JavaScript Features](#using-with-modern-javascript-features)
- [Best Practices](#best-practices)

## Core Concepts

### Iterator
An **iterator** is an object that implements the iterator protocol by having a `next()` method. This method returns an object with two properties:
- `value`: the next value in the sequence
- `done`: a boolean indicating whether the iterator has finished

### Iterable
An **iterable** is an object that implements the iterable protocol by having a `Symbol.iterator` method that returns an iterator.

## Basic Iterator Example

Here's a simple iterator that counts from 1 to 3:

```javascript
const simpleIterator = {
  current: 1,
  next() {
    if (this.current <= 3) {
      return { value: this.current++, done: false };
    }
    return { value: undefined, done: true };
  }
};

console.log(simpleIterator.next()); // { value: 1, done: false }
console.log(simpleIterator.next()); // { value: 2, done: false }
console.log(simpleIterator.next()); // { value: 3, done: false }
console.log(simpleIterator.next()); // { value: undefined, done: true }
```

## Creating Iterables

To make an object iterable, you need to implement the `Symbol.iterator` method:

```javascript
const myIterable = {
  data: [1, 2, 3],
  [Symbol.iterator]() {
    let index = 0;
    const data = this.data;
    
    return {
      next() {
        if (index < data.length) {
          return { value: data[index++], done: false };
        }
        return { value: undefined, done: true };
      }
    };
  }
};

// Now you can use it with for...of
for (const value of myIterable) {
  console.log(value); // 1, 2, 3
}
```

### More Complex Iterable Example

```javascript
class NumberSequence {
  constructor(start, end, step = 1) {
    this.start = start;
    this.end = end;
    this.step = step;
  }

  [Symbol.iterator]() {
    let current = this.start;
    const end = this.end;
    const step = this.step;

    return {
      next() {
        if (current <= end) {
          const value = current;
          current += step;
          return { value, done: false };
        }
        return { value: undefined, done: true };
      }
    };
  }
}

const sequence = new NumberSequence(0, 10, 2);
console.log([...sequence]); // [0, 2, 4, 6, 8, 10]
```

## Built-in Iterables

Many JavaScript objects are already iterable:

### Arrays
```javascript
const arr = [1, 2, 3];
for (const item of arr) {
  console.log(item); // 1, 2, 3
}
```

### Strings
```javascript
for (const char of "hello") {
  console.log(char); // h, e, l, l, o
}
```

### Maps
```javascript
const map = new Map([['a', 1], ['b', 2], ['c', 3]]);
for (const [key, value] of map) {
  console.log(`${key}: ${value}`); // a: 1, b: 2, c: 3
}
```

### Sets
```javascript
const set = new Set([1, 2, 3, 2, 1]);
for (const value of set) {
  console.log(value); // 1, 2, 3
}
```

### NodeLists
```javascript
// In a browser environment
const elements = document.querySelectorAll('div');
for (const element of elements) {
  console.log(element);
}
```

## Generator Functions

Generator functions provide an elegant way to create iterators using the `function*` syntax and `yield` keyword:

### Basic Generator
```javascript
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = numberGenerator();
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }

// Generators are iterable
for (const num of numberGenerator()) {
  console.log(num); // 1, 2, 3
}
```

### Generator with Logic
```javascript
function* evenNumbers(limit) {
  for (let i = 0; i <= limit; i += 2) {
    yield i;
  }
}

console.log([...evenNumbers(10)]); // [0, 2, 4, 6, 8, 10]
```

## Practical Applications

### Custom Range Iterator
```javascript
function* range(start, end, step = 1) {
  for (let i = start; i <= end; i += step) {
    yield i;
  }
}

console.log([...range(1, 5)]); // [1, 2, 3, 4, 5]
console.log([...range(0, 10, 2)]); // [0, 2, 4, 6, 8, 10]
```

### Infinite Sequences
```javascript
function* fibonacci() {
  let a = 0, b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

// Take first 10 fibonacci numbers
function take(n, iterable) {
  const result = [];
  const iterator = iterable[Symbol.iterator]();
  for (let i = 0; i < n; i++) {
    const { value, done } = iterator.next();
    if (done) break;
    result.push(value);
  }
  return result;
}

console.log(take(10, fibonacci())); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

### Tree Traversal
```javascript
class TreeNode {
  constructor(value, left = null, right = null) {
    this.value = value;
    this.left = left;
    this.right = right;
  }

  *inorderTraversal() {
    if (this.left) {
      yield* this.left.inorderTraversal();
    }
    yield this.value;
    if (this.right) {
      yield* this.right.inorderTraversal();
    }
  }
}

const tree = new TreeNode(4,
  new TreeNode(2,
    new TreeNode(1),
    new TreeNode(3)
  ),
  new TreeNode(6,
    new TreeNode(5),
    new TreeNode(7)
  )
);

console.log([...tree.inorderTraversal()]); // [1, 2, 3, 4, 5, 6, 7]
```

### Async Iterators
```javascript
async function* asyncNumberGenerator() {
  for (let i = 1; i <= 3; i++) {
    await new Promise(resolve => setTimeout(resolve, 1000));
    yield i;
  }
}

// Usage with for await...of
async function example() {
  for await (const num of asyncNumberGenerator()) {
    console.log(num); // 1 (after 1s), 2 (after 2s), 3 (after 3s)
  }
}
```

## Using with Modern JavaScript Features

### Destructuring
```javascript
const [first, second, ...rest] = range(1, 5);
console.log(first); // 1
console.log(second); // 2
console.log(rest); // [3, 4, 5]
```

### Spread Operator
```javascript
const array = [...range(1, 3)];
console.log(array); // [1, 2, 3]

const combined = [...range(1, 3), ...range(10, 12)];
console.log(combined); // [1, 2, 3, 10, 11, 12]
```

### Array.from()
```javascript
const array = Array.from(range(1, 5));
console.log(array); // [1, 2, 3, 4, 5]

// With mapping function
const doubled = Array.from(range(1, 3), x => x * 2);
console.log(doubled); // [2, 4, 6]
```

### Promise.all() with Iterables
```javascript
async function* asyncRange(start, end) {
  for (let i = start; i <= end; i++) {
    yield Promise.resolve(i);
  }
}

const promises = [...asyncRange(1, 3)];
const results = await Promise.all(promises);
console.log(results); // [1, 2, 3]
```

## Best Practices

### 1. Always Handle the Done State
```javascript
function consumeIterator(iterator) {
  let result;
  while (!(result = iterator.next()).done) {
    console.log(result.value);
  }
}
```

### 2. Make Objects Both Iterable and Iterator
```javascript
class Counter {
  constructor(max) {
    this.max = max;
  }

  [Symbol.iterator]() {
    let count = 0;
    const max = this.max;

    return {
      next() {
        if (count < max) {
          return { value: count++, done: false };
        }
        return { value: undefined, done: true };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  }
}
```

### 3. Use Generators for Complex Logic
Instead of manually implementing iterators, prefer generators when you need complex iteration logic:

```javascript
// Prefer this
function* fibonacci() {
  let a = 0, b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

// Over this
const fibonacciIterator = {
  a: 0,
  b: 1,
  next() {
    const value = this.a;
    [this.a, this.b] = [this.b, this.a + this.b];
    return { value, done: false };
  }
};
```

### 4. Handle Early Termination
```javascript
function* resourceGenerator() {
  try {
    const resource = acquireResource();
    yield resource;
    yield anotherResource();
  } finally {
    // Cleanup code runs even if iteration is stopped early
    releaseResource();
  }
}
```

## Conclusion

The iterator protocol is a powerful feature that enables JavaScript's iteration mechanisms. Understanding iterators and iterables allows you to:

- Create custom data structures that work seamlessly with JavaScript's iteration features
- Write more expressive and functional code
- Handle sequences of data efficiently
- Build powerful abstractions for data processing

Whether you're working with simple collections or complex data streams, the iterator protocol provides a standardized and flexible approach to sequence handling in JavaScript.