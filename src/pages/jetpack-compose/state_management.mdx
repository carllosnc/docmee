---
layout: ../../layout/main-layout.astro
---
<a href="/jetpack-compose">← Jetpack Compose</a> <br /> <br />

# State Management

State management in Jetpack Compose is crucial for building reactive and dynamic UIs. Compose uses a declarative approach, where the UI is a function of state, and updates automatically when the state changes. This documentation focuses on practical code examples for managing state in Jetpack Compose, with brief descriptions of each approach.

## 1. Using `remember` for Local State

The `remember` composable retains state across recompositions. It’s ideal for simple, local state within a composable.

```kotlin
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.material3.Button
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier

@Composable
fun CounterScreen() {
    var count by remember { mutableIntStateOf(0) }
    
    Button(onClick = { count++ }) {
        Text("Count: $count")
    }
}
```

**Description**: The `count` variable is stored using `remember` with `mutableIntStateOf`, ensuring the state persists across recompositions. Clicking the button increments the count, triggering a UI update.

## 2. Using `rememberSaveable` for Surviving Configuration Changes

`rememberSaveable` preserves state across configuration changes (e.g., screen rotations) by saving state in a `Bundle`.

```kotlin
import androidx.compose.runtime.Composable
import androidx.compose.runtime.rememberSaveable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.material3.TextField
import androidx.compose.material3.Text

@Composable
fun TextInputScreen() {
    var text by rememberSaveable { mutableStateOf("") }
    
    TextField(
        value = text,
        onValueChange = { text = it },
        label = { Text("Enter text") }
    )
}
```

**Description**: The `text` state is preserved using `rememberSaveable`, so it persists during configuration changes like rotation. The `TextField` updates the state as the user types.

## 3. State Hoisting with Callbacks

State hoisting moves state management to a higher level in the composable hierarchy, promoting reusability and testability.

```kotlin
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.runtime.remember
import androidx.compose.runtime.mutableStateOf
import androidx.compose.material3.Button
import androidx.compose.material3.Text

@Composable
fun CounterScreen() {
    var count by remember { mutableIntStateOf(0) }
    CounterDisplay(count = count, onCountChange = { count++ })
}

@Composable
fun CounterDisplay(count: Int, onCountChange: () -> Unit) {
    Button(onClick = onCountChange) {
        Text("Count: $count")
    }
}
```

**Description**: The `count` state is managed in `CounterScreen`, while `CounterDisplay` is a stateless composable that receives the state and a callback to modify it. This approach makes `CounterDisplay` reusable.

## 4. Using ViewModel for Persistent State

`ViewModel` manages UI-related data across configuration changes and process death, suitable for complex state logic.

```kotlin
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.compose.material3.Button
import androidx.compose.material3.Text

class CounterViewModel : ViewModel() {
    var count by mutableStateOf(0)
        private set
    
    fun increment() {
        count++
    }
}

@Composable
fun CounterScreen(viewModel: CounterViewModel = CounterViewModel()) {
    Button(onClick = { viewModel.increment() }) {
        Text("Count: ${viewModel.count}")
    }
}
```

**Description**: The `CounterViewModel` holds the `count` state and exposes an `increment` function. The composable observes the state and updates the UI when the count changes, surviving configuration changes.

## 5. Using StateFlow for Reactive State

`StateFlow` is used for reactive state management, often in conjunction with `ViewModel`, to handle asynchronous data streams.

```kotlin
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.compose.material3.Button
import androidx.compose.material3.Text
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class TimerViewModel : ViewModel() {
    private val _seconds = MutableStateFlow(0)
    val seconds: StateFlow<Int> = _seconds
    
    fun startTimer() {
        viewModelScope.launch {
            while (true) {
                kotlinx.coroutines.delay(1000)
                _seconds.value++
            }
        }
    }
}

@Composable
fun TimerScreen(viewModel: TimerViewModel = viewModel()) {
    val seconds by viewModel.seconds.collectAsState()
    
    Button(onClick = { viewModel.startTimer() }) {
        Text("Seconds: $seconds")
    }
}
```

**Description**: The `TimerViewModel` uses `StateFlow` to emit seconds. The composable collects the flow using `collectAsState`, updating the UI reactively as the timer increments.

## 6. Using LiveData with Compose

`LiveData` can be used for state management, especially when integrating with legacy code or libraries.

```kotlin
import androidx.compose.runtime.Composable
import androidx.compose.runtime.livedata.observeAsState
import androidx.lifecycle.ViewModel
import androidx.lifecycle.MutableLiveData
import androidx.compose.material3.Button
import androidx.compose.material3.Text
import androidx.lifecycle.viewmodel.compose.viewModel

class SwitchViewModel : ViewModel() {
    private val _isEnabled = MutableLiveData(false)
    val isEnabled: LiveData<Boolean> = _isEnabled
    
    fun toggle() {
        _isEnabled.value = !(_isEnabled.value ?: false)
    }
}

@Composable
fun SwitchScreen(viewModel: SwitchViewModel = viewModel()) {
    val isEnabled by viewModel.isEnabled.observeAsState(false)
    
    Button(onClick = { viewModel.toggle() }) {
        Text(if (isEnabled) "ON" else "OFF")
    }
}
```

**Description**: The `SwitchViewModel` uses `LiveData` to manage a boolean state. The composable observes it with `observeAsState`, updating the UI when the state toggles.

## 7. Managing State with CompositionLocal

`CompositionLocal` provides a way to pass data implicitly through the composable tree, useful for app-wide state like themes.

```kotlin
import androidx.compose.runtime.Composable
import androidx.compose.runtime.compositionLocalOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.runtime.remember
import androidx.compose.runtime.mutableStateOf
import androidx.compose.material3.Button
import androidx.compose.material3.Text

val LocalTheme = compositionLocalOf { false }

@Composable
fun ThemeApp() {
    var isDarkTheme by remember { mutableStateOf(false) }
    
    CompositionLocalProvider(LocalTheme provides isDarkTheme) {
        ThemeConsumer()
    }
}

@Composable
fun ThemeConsumer() {
    val isDarkTheme = LocalTheme.current
    
    Button(onClick = { /* Toggle theme */ }) {
        Text(if (isDarkTheme) "Dark Theme" else "Light Theme")
    }
}
```

**Description**: `LocalTheme` provides a boolean to indicate the theme. `CompositionLocalProvider` sets the theme value, which `ThemeConsumer` reads implicitly, avoiding prop drilling.

## 8. Snapshot State with `derivedStateOf`

`derivedStateOf` creates a state derived from other states, recomputing only when dependencies change.

```kotlin
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.runtime.remember
import androidx.compose.runtime.derivedStateOf
import androidx.compose.material3.TextField
import androidx.compose.material3.Text

@Composable
fun FormScreen() {
    var name by remember { mutableStateOf("") }
    val isValid by remember { derivedStateOf { name.length >= 3 } }
    
    TextField(
        value = name,
        onValueChange = { name = it },
        label = { Text("Name") }
    )
    Text(if (isValid) "Valid name" else "Name too short")
}
```

**Description**: The `isValid` state is derived from `name` using `derivedStateOf`. It updates only when `name` changes, optimizing recomposition.

## Key Points

- **Use `remember`** for simple, local state.
- **Use `rememberSaveable`** for state that needs to survive configuration changes.
- **Hoist state** to make composables reusable and testable.
- **Use ViewModel** for complex logic and process-death survival.
- **Use StateFlow** for reactive streams, and `LiveData` for legacy integration.
- **Use CompositionLocal** for implicit state passing.
- **Use `derivedStateOf`** for computed state to optimize performance.

These examples demonstrate practical state management techniques in Jetpack Compose, balancing simplicity and scalability.