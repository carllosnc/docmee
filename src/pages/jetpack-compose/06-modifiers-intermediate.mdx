---
layout: ../../layout/main-layout.astro
---
<a href="/jetpack-compose">‚Üê Jetpack Compose </a> <br /> <br />

# Intermediate: Modifier.border(), Modifier.clip(), Modifier.alpha()

Advanced visual modifiers for creating polished UI elements with borders, clipping, and transparency effects.

## Basic Border Usage

```kotlin
@Composable
fun BasicBorders() {
    Column(
        modifier = Modifier.padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Simple border
        Box(
            modifier = Modifier
                .size(100.dp)
                .border(2.dp, Color.Blue)
                .background(Color.LightBlue)
        )

        // Border with rounded corners
        Box(
            modifier = Modifier
                .size(100.dp)
                .border(3.dp, Color.Red, RoundedCornerShape(16.dp))
                .background(Color.Pink, RoundedCornerShape(16.dp))
        )
        
        // Gradient border
        Box(
            modifier = Modifier
                .size(100.dp)
                .border(
                    4.dp, 
                    Brush.linearGradient(
                        colors = listOf(Color.Red, Color.Blue, Color.Green)
                    ),
                    RoundedCornerShape(8.dp)
                )
                .background(Color.White, RoundedCornerShape(8.dp))
        )
    }
}
```

Border is drawn outside the background. Shape must match between border and background.

## Advanced Border Patterns

```kotlin
@Composable
fun AdvancedBorders() {
    Column(
        modifier = Modifier.padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Dashed border effect (using multiple borders)
        Box(
            modifier = Modifier
                .size(120.dp)
                .drawBehind {
                    drawRoundRect(
                        color = Color.Gray,
                        style = Stroke(
                            width = 3.dp.toPx(),
                            pathEffect = PathEffect.dashPathEffect(
                                floatArrayOf(10f, 10f), 0f
                            )
                        ),
                        cornerRadius = CornerRadius(8.dp.toPx())
                    )
                }
                .background(Color.LightGray, RoundedCornerShape(8.dp))
        )
        
        // Multiple borders
        Box(
            modifier = Modifier
                .size(100.dp)
                .border(4.dp, Color.Red, CircleShape)
                .padding(4.dp)
                .border(2.dp, Color.Blue, CircleShape)
                .background(Color.White, CircleShape)
        )
        
        // Conditional border
        var hasBorder by remember { mutableStateOf(true) }
        
        Box(
            modifier = Modifier
                .size(80.dp)
                .clickable { hasBorder = !hasBorder }
                .then(
                    if (hasBorder) {
                        Modifier.border(2.dp, Color.Green, RoundedCornerShape(12.dp))
                    } else {
                        Modifier
                    }
                )
                .background(Color.LightGreen, RoundedCornerShape(12.dp)),
            contentAlignment = Alignment.Center
        ) {
            Text("Tap", fontSize = 12.sp)
        }
    }
}
```

Use `drawBehind` for custom border effects like dashes. Layer borders with padding.

## Basic Clipping

```kotlin
@Composable
fun BasicClipping() {
    Row(
        modifier = Modifier.padding(16.dp),
        horizontalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Rectangular clip
        Image(
            painter = painterResource(R.drawable.sample_image),
            contentDescription = null,
            modifier = Modifier
                .size(100.dp)
                .clip(RectangleShape)
                .background(Color.Gray),
            contentScale = ContentScale.Crop
        )
        
        // Rounded corner clip
        Image(
            painter = painterResource(R.drawable.sample_image),
            contentDescription = null,
            modifier = Modifier
                .size(100.dp)
                .clip(RoundedCornerShape(16.dp))
                .background(Color.Gray),
            contentScale = ContentScale.Crop
        )
        
        // Circle clip
        Image(
            painter = painterResource(R.drawable.sample_image),
            contentDescription = null,
            modifier = Modifier
                .size(100.dp)
                .clip(CircleShape)
                .background(Color.Gray),
            contentScale = ContentScale.Crop
        )
    }
}
```

Clipping is essential for images and overflow content. Apply before background for clean edges.

## Custom Shapes and Clipping

```kotlin
@Composable
fun CustomShapeClipping() {
    // Triangle shape
    val triangleShape = GenericShape { size, _ ->
        moveTo(size.width / 2f, 0f)
        lineTo(size.width, size.height)
        lineTo(0f, size.height)
        close()
    }
    
    // Diamond shape
    val diamondShape = GenericShape { size, _ ->
        moveTo(size.width / 2f, 0f)
        lineTo(size.width, size.height / 2f)
        lineTo(size.width / 2f, size.height)
        lineTo(0f, size.height / 2f)
        close()
    }
    
    Row(
        modifier = Modifier.padding(16.dp),
        horizontalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Box(
            modifier = Modifier
                .size(100.dp)
                .clip(triangleShape)
                .background(Color.Red)
        )
        
        Box(
            modifier = Modifier
                .size(100.dp)
                .clip(diamondShape)
                .background(Color.Blue)
        )
        
        // Cut corner shape
        Box(
            modifier = Modifier
                .size(100.dp)
                .clip(CutCornerShape(16.dp))
                .background(Color.Green)
        )
    }
}
```

Use `GenericShape` for custom clipping paths. `CutCornerShape` cuts instead of rounds.

## Alpha Transparency

```kotlin
@Composable
fun AlphaExamples() {
    Column(
        modifier = Modifier.padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Fixed alpha values
        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
            listOf(1f, 0.8f, 0.6f, 0.4f, 0.2f).forEach { alpha ->
                Box(
                    modifier = Modifier
                        .size(60.dp)
                        .alpha(alpha)
                        .background(Color.Blue, CircleShape)
                )
            }
        }
        
        // Animated alpha
        var isVisible by remember { mutableStateOf(true) }
        val alpha by animateFloatAsState(
            targetValue = if (isVisible) 1f else 0.3f,
            animationSpec = tween(1000),
            label = "alpha"
        )
        
        Box(
            modifier = Modifier
                .size(120.dp)
                .clickable { isVisible = !isVisible }
                .alpha(alpha)
                .background(Color.Red, RoundedCornerShape(16.dp)),
            contentAlignment = Alignment.Center
        ) {
            Text("Tap to fade", color = Color.White)
        }
        
        // Progressive alpha in list
        LazyColumn(
            modifier = Modifier.height(200.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            items(10) { index ->
                val itemAlpha = 1f - (index * 0.1f)
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .alpha(itemAlpha)
                ) {
                    Text(
                        "Item $index (Alpha: ${String.format("%.1f", itemAlpha)})",
                        modifier = Modifier.padding(16.dp)
                    )
                }
            }
        }
    }
}
```

Alpha affects entire composable and its children. Use with animations for smooth transitions.

## Combining All Three Modifiers

```kotlin
@Composable
fun CombinedModifiers() {
    var isExpanded by remember { mutableStateOf(false) }
    
    val animatedSize by animateDpAsState(
        targetValue = if (isExpanded) 150.dp else 100.dp,
        animationSpec = spring(dampingRatio = Spring.DampingRatioMediumBouncy),
        label = "size"
    )
    
    val animatedAlpha by animateFloatAsState(
        targetValue = if (isExpanded) 0.9f else 1f,
        label = "alpha"
    )
    
    val animatedBorderWidth by animateDpAsState(
        targetValue = if (isExpanded) 6.dp else 2.dp,
        label = "border"
    )
    
    Box(
        modifier = Modifier
            .size(animatedSize)
            .clickable { isExpanded = !isExpanded }
            .alpha(animatedAlpha)
            .clip(RoundedCornerShape(if (isExpanded) 24.dp else 12.dp))
            .border(
                animatedBorderWidth,
                if (isExpanded) Color.Red else Color.Blue,
                RoundedCornerShape(if (isExpanded) 24.dp else 12.dp)
            )
            .background(
                if (isExpanded) Color.LightGray else Color.White,
                RoundedCornerShape(if (isExpanded) 24.dp else 12.dp)
            ),
        contentAlignment = Alignment.Center
    ) {
        Text(
            if (isExpanded) "Expanded!" else "Tap me",
            fontSize = if (isExpanded) 16.sp else 14.sp
        )
    }
}
```

## Practical Card Example

```kotlin
@Composable
fun StyledCard() {
    var isPressed by remember { mutableStateOf(false) }
    
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
            .clip(RoundedCornerShape(12.dp))
            .border(
                1.dp,
                if (isPressed) Color.Blue else Color.Gray.copy(alpha = 0.3f),
                RoundedCornerShape(12.dp)
            )
            .clickable { isPressed = !isPressed }
            .alpha(if (isPressed) 0.8f else 1f),
        elevation = CardDefaults.cardElevation(
            defaultElevation = if (isPressed) 8.dp else 4.dp
        )
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                "Styled Card",
                style = MaterialTheme.typography.headlineSmall,
                color = if (isPressed) Color.Blue else Color.Black
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Text(
                "This card demonstrates border, clip, and alpha modifiers working together.",
                style = MaterialTheme.typography.bodyMedium,
                color = Color.Gray
            )
            
            Spacer(modifier = Modifier.height(12.dp))
            
            // Clipped image
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(100.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(Color.LightBlue)
                    .border(1.dp, Color.Blue, RoundedCornerShape(8.dp)),
                contentAlignment = Alignment.Center
            ) {
                Text("Image placeholder", color = Color.Blue)
            }
        }
    }
}
```

## Key Principles

- **Shape consistency**: use same shape for clip, border, and background
- **Modifier order**: clip before background, border after background
- **Alpha inheritance**: affects entire composable tree below
- **Performance**: avoid unnecessary clip operations on simple rectangles
- **Animation**: combine with `animate*AsState` for smooth transitions
- **Custom shapes**: use `GenericShape` for complex clipping paths