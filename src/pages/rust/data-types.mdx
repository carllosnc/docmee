---
layout: ../../layout/main-layout.astro
---
<a href="/rust">‚Üê Rust</a> <br /> <br />

# Data Types in Rust

Rust is a statically typed language, which means that it must know the types of all variables at compile time. This section covers the fundamental data types.

## Scalar Types

A scalar type represents a single value. Rust has four primary scalar types.

### Integers

Integers are numbers without a fractional component. They can be signed (i, can be negative) or unsigned (u, only positive).

**Example 1: Signed and Unsigned Integers**
```rust
fn main() {
    // Unsigned 32-bit integer
    let positive_number: u32 = 1_500;

    // Signed 32-bit integer
    let negative_number: i32 = -1_500;

    println!("Unsigned: {}, Signed: {}", positive_number, negative_number);
}
```

**Example 2: Sized Integers**
```rust
fn main() {
    // 8-bit integer
    let a: i8 = 10;

    // 64-bit integer
    let b: i64 = 100_000_000;

    println!("i8: {}, i64: {}", a, b);
}
```

### Floating-Point Numbers

Rust has two primitive types for floating-point numbers, which are numbers with decimal points.

**Example 1: f32 and f64**
```rust
fn main() {
    // 64-bit float (default)
    let x = 2.0; // f64

    // 32-bit float
    let y: f32 = 3.0;

    println!("x: {}, y: {}", x, y);
}
```

### Booleans

The boolean type has two possible values: `true` and `false`.

**Example 1: Boolean Variables**
```rust
fn main() {
    let is_rust_fun: bool = true;
    let is_learning_done = false;

    println!("Is Rust fun? {}", is_rust_fun);
    println!("Are we done learning? {}", is_learning_done);
}
```

### Characters

The `char` type is Rust‚Äôs most primitive alphabetic type.

**Example 1: Character Literals**
```rust
fn main() {
    let c = 'z';
    let z = '‚Ñ§';
    // Chars can even be emojis
    let heart_eyed_cat = 'üòª';

    println!("Chars: {}, {}, {}", c, z, heart_eyed_cat);
}
```

## Compound Types

Compound types can group multiple values into one type.

### Tuples

A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.

**Example 1: Creating and Destructuring a Tuple**
```rust
fn main() {
    // A tuple with different types
    let tup: (i32, f64, u8) = (500, 6.4, 1);

    // Destructuring the tuple
    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```

**Example 2: Accessing Tuple Elements by Index**
```rust
fn main() {
    let numbers = (1, 2, 3);

    // Access elements with a period (.)
    let one = numbers.0;
    let two = numbers.1;

    println!("First element is: {}", one);
}
```

### Arrays

Another way to have a collection of multiple values is with an array. Unlike a tuple, every element of an array must have the same type. Arrays in Rust have a fixed length.

**Example 1: Creating an Array**
```rust
fn main() {
    // An array of 5 integers
    let a = [1, 2, 3, 4, 5];

    // Access an element
    let first = a[0];
    println!("The first element is: {}", first);
}
```

**Example 2: Array with Type and Length**
```rust
fn main() {
    // [type; length]
    let b: [i32; 5] = [1, 2, 3, 4, 5];
    println!("The second element is: {}", b[1]);
}
```

**Example 3: Initialize an Array with the Same Value**
```rust
fn main() {
    // An array of 5 elements, all initialized to 3
    let c = [3; 5]; // [3, 3, 3, 3, 3]
    println!("The third element is: {}", c[2]);
}
```
