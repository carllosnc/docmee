---
layout: ../../layout/main-layout.astro
---
<a href="/rust">‚Üê Rust</a> <br /> <br />

# Rust Primitive Data Types

Rust is a statically typed language, which means it must know the types of all variables at compile time. However, the compiler can often infer the type based on the value and how we use it. When ambiguity arises, we must add a type annotation.

Here are the primitive data types in Rust:

*   **Integers:** `i8`, `i16`, `i32`, `i64`, `i128`, `isize`, `u8`, `u16`, `u32`, `u64`, `u128`, `usize`
*   **Floating-Point Numbers:** `f32`, `f64`
*   **Booleans:** `bool`
*   **Characters:** `char`
*   **Tuples:** `(T1, T2, ...)`
*   **Arrays:** `[T; N]`
*   **String Slices:** `&str`

## 1. Integers

Integers are whole numbers. Rust has various integer types, categorized by their size (number of bits they use) and whether they are signed or unsigned.

*   **Signed Integers (i8, i16, i32, i64, i128, isize):** Can store both positive and negative numbers. The `isize` type's size depends on the architecture of the computer (64 bits on a 64-bit architecture and 32 bits on a 32-bit architecture).
*   **Unsigned Integers (u8, u16, u32, u64, u128, usize):** Can only store positive numbers. The `usize` type's size also depends on the architecture.

By default, Rust integers are `i32`.

```rust
fn main() {
    let x: i32 = 42; // Explicitly typed i32
    let y = 100;     // Inferred as i32
    let z: u64 = 1_000_000; // Unsigned 64-bit integer with a visual separator
    let negative_num: i8 = -120; // Signed 8-bit integer
    let arch_dependent: isize = 500; // Architecture-dependent signed integer
}
```

## 2. Floating-Point Numbers

Rust has two primitive floating-point types:

*   **f32:** Single-precision float.
*   **f64:** Double-precision float. This is the default floating-point type because it offers more precision.

```rust
fn main() {
    let pi = 3.14;    // Inferred as f64
    let e: f32 = 2.718; // Explicitly typed f32
}
```

## 3. Booleans

Booleans have two possible values: `true` or `false`. They are one byte in size.

```rust
fn main() {
    let is_rust_fun = true;
    let is_raining: bool = false; // Explicitly typed bool
}
```

## 4. Characters

Rust's `char` type is a Unicode Scalar Value, meaning it can represent a lot more than just ASCII. It's four bytes in size.

```rust
fn main() {
    let initial = 'R';
    let emoji = 'üòÇ';
    let z: char = 'Z'; // Explicitly typed char
}
```

## 5. Tuples

Tuples are a way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.

```rust
fn main() {
    let person_data = ("Alice", 30, true); // A tuple with different types
    let (name, age, is_active) = person_data; // Destructuring a tuple

    println!("Name: {}", name);
    println!("Age: {}", person_data.1); // Accessing elements by index
}
```

## 6. Arrays

Arrays are a collection of values of the *same type*. Like tuples, arrays have a fixed length. They are useful when you want your data allocated on the stack rather than the heap.

```rust
fn main() {
    let numbers = [1, 2, 3, 4, 5]; // Array of 5 i32 integers
    let bytes: [u8; 3] = [0, 1, 2]; // Explicitly typed array of 3 u8 integers

    println!("First number: {}", numbers[0]);
    println!("Array length: {}", numbers.len());
}
```

## 7. String Slices (`&str`)

While `String` (owned, growable string) is a complex type, `&str` (string slice) is a primitive reference to a sequence of UTF-8 bytes. It's often considered a primitive way to handle text.

```rust
fn main() {
    let greeting: &str = "Hello, Rust!"; // A string slice
    println!("{}", greeting);
}
```
