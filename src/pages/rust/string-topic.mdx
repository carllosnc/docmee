# Strings in Rust

Strings in Rust are a fundamental data type used to represent text. Rust provides two primary string types: `String` and `&str` (string slice). This document explains their characteristics, usage, and key concepts, including ownership, borrowing, and common operations.

## 1. The Two String Types: `String` and `&str`

### `String`
- **Definition**: A `String` is a growable, mutable, owned, heap-allocated string type. It is part of the Rust standard library (`std::string::String`).
- **Characteristics**:
  - Stored on the heap, allowing dynamic resizing.
  - Owns its data, meaning it has full control over the memory it uses.
  - Mutable, so you can modify its contents (e.g., append, clear, or replace).
  - UTF-8 encoded, ensuring compatibility with all Unicode characters.
- **Use Case**: Use `String` when you need a string that can be modified or when you need to own the string data (e.g., when passing it across functions or storing it in a struct).

### `&str`
- **Definition**: A `&str` (pronounced "string slice") is an immutable reference to a sequence of UTF-8 encoded bytes, typically stored in a `String`, a static string, or elsewhere in memory.
- **Characteristics**:
  - Immutable by default (you cannot modify the data it points to unless using unsafe code or specific constructs).
  - Usually a borrowed reference, meaning it doesn't own the data.
  - Can point to a portion of a `String`, a static string (`"hello"`), or other string data.
  - Lightweight and efficient for passing string data without copying.
- **Use Case**: Use `&str` when you need to read string data without modifying it or when passing string literals.

### Key Differences
| Feature            | `String`                          | `&str`                           |
|--------------------|-----------------------------------|----------------------------------|
| **Ownership**      | Owns the data (heap-allocated)   | Borrows the data (reference)     |
| **Mutability**     | Mutable                         | Immutable                        |
| **Storage**        | Heap                            | Anywhere (stack, heap, static)   |
| **Use Case**       | Modifiable strings              | Read-only string data            |

## 2. Creating Strings

### Creating a `String`
You can create a `String` in several ways:
```rust
// From a string literal
let s1 = String::from("Hello, Rust!");
let s2 = "Hello, Rust!".to_string();

// Empty string
let s3 = String::new();

// From a string slice
let s4 = String::from("Hello");

// With capacity
let mut s5 = String::with_capacity(20); // Pre-allocate 20 bytes
```

### Creating a `&str`
String slices are often created implicitly from string literals or by borrowing from a `String`:
```rust
// From a string literal
let s: &str = "Hello, Rust!";

// Borrowing from a String
let owned = String::from("Hello, Rust!");
let s_ref: &str = &owned;
```

## 3. Ownership and Borrowing

Rust's ownership model significantly impacts how strings are used:
- **`String` Ownership**: Since `String` owns its data, when you pass it to a function or assign it to a new variable, the ownership moves unless you clone it:
  ```rust
  let s1 = String::from("Hello");
  let s2 = s1; // s1 is moved, no longer usable
  // println!("{}", s1); // Error: s1 was moved
  println!("{}", s2); // Works
  ```
  To avoid moving, you can clone:
  ```rust
  let s1 = String::from("Hello");
  let s2 = s1.clone(); // Deep copy
  println!("s1: {}, s2: {}", s1, s2); // Both work
  ```

- **`&str` Borrowing**: Since `&str` is a reference, it follows Rust's borrowing rules. You can have multiple immutable references (`&str`) but only one mutable reference (`&mut String`) at a time:
  ```rust
  let s = String::from("Hello");
  let r1: &str = &s; // Immutable borrow
  let r2: &str = &s; // Another immutable borrow
  println!("r1: {}, r2: {}", r1, r2); // Works
  // let r3 = &mut s; // Error: cannot borrow mutably when immutable borrows exist
  ```

## 4. Common Operations

### Concatenation
- **With `String`**:
  ```rust
  let mut s = String::from("Hello");
  s.push_str(", "); // Append a &str
  s.push('R'); // Append a single char
  println!("{}", s); // Output: Hello, R

  let s1 = String::from("Hello");
  let s2 = String::from("Rust");
  let s3 = s1 + &s2; // s1 is moved, s2 is borrowed
  // println!("{}", s1); // Error: s1 was moved
  println!("s3: {}", s3); // Output: HelloRust
  ```
  Note: The `+` operator moves the first `String` and borrows the second as a `&str`.

- **With `&str`**:
  ```rust
  let s1: &str = "Hello";
  let s2: &str = "Rust";
  let s3 = format!("{}, {}!", s1, s2); // format! creates a new String
  println!("{}", s3); // Output: Hello, Rust!
  ```

### Slicing
You can create a `&str` from a portion of a `String` or another `&str`:
```rust
let s = String::from("Hello, Rust!");
let slice = &s[0..5]; // "Hello"
println!("{}", slice);
```
**Caution**: Rust enforces UTF-8 boundaries, so slicing must align with valid character boundaries:
```rust
let s = String::from("Hello");
let invalid = &s[0..1]; // OK: "H"
let invalid = &s[0..2]; // OK: "He"
// let invalid = &s[0..3]; // Panic: not a char boundary
```

### Iteration
Strings in Rust are UTF-8 encoded, so you iterate over characters or bytes:
```rust
let s = String::from("Hello, 世界!");

// Iterate over characters
for c in s.chars() {
    println!("{}", c);
}

// Iterate over bytes
for b in s.bytes() {
    println!("{}", b);
}
```

### Common Methods
- **For `String`**:
  - `push_str(&str)`: Append a string slice.
  - `push(char)`: Append a single character.
  - `clear()`: Empty the string.
  - `len()`: Get the byte length.
  - `capacity()`: Get the allocated capacity.
  - `replace(&str, &str)`: Replace all occurrences of a substring.
- **For `&str`**:
  - `len()`: Get the byte length.
  - `contains(&str)`: Check if a substring exists.
  - `split(&str)`: Split into an iterator of substrings.
  - `trim()`: Remove leading/trailing whitespace.

Example:
```rust
let mut s = String::from("  Hello, Rust!  ");
println!("{}", s.trim()); // Output: Hello, Rust!
println!("{}", s.contains("Rust")); // Output: true
```

## 5. String Conversion

- **From `&str` to `String`**:
  ```rust
  let s: &str = "Hello";
  let owned = s.to_string(); // or String::from(s)
  ```

- **From `String` to `&str`**:
  ```rust
  let s = String::from("Hello");
  let slice: &str = &s; // or s.as_str()
  ```

- **To C-style strings** (for FFI):
  ```rust
  let s = String::from("Hello");
  let c_str = std::ffi::CString::new(s).unwrap();
  ```

## 6. UTF-8 and Unicode Considerations

Rust strings are UTF-8 encoded, which means:
- A `char` in Rust is a Unicode scalar value (4 bytes), not a single byte.
- The `len()` method returns the number of bytes, not characters:
  ```rust
  let s = String::from("世界");
  println!("Bytes: {}", s.len()); // Output: 6 (3 bytes per character)
  println!("Chars: {}", s.chars().count()); // Output: 2
  ```
- Be cautious when indexing or slicing to avoid panics due to invalid UTF-8 boundaries.

## 7. Performance Considerations

- **Use `&str` for efficiency**: Since `&str` is a reference, it avoids unnecessary allocations and copies.
- **Pre-allocate `String` capacity**: Use `String::with_capacity` to avoid reallocations when building strings.
- **Avoid excessive cloning**: Use borrowing (`&str`) when possible instead of `String::clone`.
- **Use `format!` for concatenation**: It’s often clearer and avoids ownership issues.

## 8. Common Pitfalls

- **Ownership Errors**: Forgetting that `String` moves when assigned or passed to functions.
- **Invalid Slicing**: Slicing at non-character boundaries causes panics.
- **Mixing Types**: Passing a `String` when a `&str` is expected (use `&s` or `s.as_str()`).
- **Unicode Complexity**: Assuming `len()` returns character count instead of byte count.

## 9. Example Program

Here’s a complete example demonstrating various string operations:
```rust
fn main() {
    // Creating strings
    let mut s = String::from("Hello");
    let s_ref: &str = "Rust";

    // Concatenation
    s.push_str(", ");
    s.push_str(s_ref);
    println!("Concatenated: {}", s); // Output: Hello, Rust

    // Slicing
    let slice = &s[0..5];
    println!("Slice: {}", slice); // Output: Hello

    // Iteration
    println!("Characters:");
    for c in s.chars() {
        print!("{} ", c);
    }
    println!(); // Output: H e l l o ,   R u s t

    // String conversion
    let new_s = s_ref.to_string();
    println!("Converted: {}", new_s); // Output: Rust

    // Check length and content
    println!("Length in bytes: {}", s.len()); // Output: 11
    println!("Contains 'Rust': {}", s.contains("Rust")); // Output: true
}
```

## 10. Further Reading
- [The Rust Book: Strings](https://doc.rust-lang.org/book/ch08-02-strings.html)
- [Rust API Documentation: `std::string::String`](https://doc.rust-lang.org/std/string/struct.String.html)
- [Rust API Documentation: `str`](https://doc.rust-lang.org/std/primitive.str.html)

This covers the essentials of working with strings in Rust, from creation to manipulation, while respecting Rust’s ownership and safety guarantees.