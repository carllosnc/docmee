# Coroutines

Coroutines are one of Kotlin's most powerful features for handling asynchronous programming and concurrency. They provide a way to write asynchronous code that looks and feels like synchronous code, making it easier to read, write, and maintain.

## What are Coroutines?

Coroutines are lightweight threads that can be suspended and resumed without blocking the underlying thread. Unlike traditional threads, you can create thousands of coroutines with minimal overhead. They're designed to handle asynchronous operations like network calls, database operations, or any long-running tasks without freezing your application.

## Key Concepts

**Suspension**: Coroutines can be suspended at certain points and resumed later. When a coroutine is suspended, it doesn't block the thread it's running on, allowing other coroutines to execute.

**Cooperative Multitasking**: Coroutines voluntarily yield control at suspension points, rather than being preemptively scheduled like threads.

**Structured Concurrency**: Coroutines follow a structured approach where child coroutines are tied to their parent scope, ensuring proper cleanup and cancellation.

## Core Components

### Suspend Functions

Functions marked with the `suspend` keyword can only be called from within a coroutine or another suspend function. These functions can pause execution without blocking threads.

```kotlin
suspend fun fetchData(): String {
    delay(1000) // Suspends for 1 second
    return "Data fetched"
}
```

### Coroutine Builders

Functions that create and start coroutines:

- `launch`: Starts a coroutine that doesn't return a result
- `async`: Starts a coroutine that returns a result via `Deferred`
- `runBlocking`: Blocks the current thread until the coroutine completes

### Coroutine Scope

Defines the lifecycle and context for coroutines. Common scopes include `GlobalScope`, `CoroutineScope`, and lifecycle-aware scopes in Android.

### Coroutine Context

Contains elements like the dispatcher (which thread pool to use) and job (for cancellation).

## Dispatchers

Dispatchers determine which thread or thread pool a coroutine runs on:

- `Dispatchers.Main`: UI thread (Android)
- `Dispatchers.IO`: I/O operations like network calls or file operations
- `Dispatchers.Default`: CPU-intensive work
- `Dispatchers.Unconfined`: Starts in the caller thread but can resume in any thread

## Basic Usage Examples

### Simple Coroutine Launch

```kotlin
import kotlinx.coroutines.*

fun main() {
    runBlocking {
        launch {
            delay(1000)
            println("Hello from coroutine!")
        }
        println("Hello from main!")
    }
}
```

### Using Async for Concurrent Operations

```kotlin
suspend fun fetchUserData(): User = // ... network call
suspend fun fetchUserPosts(): List<Post> = // ... network call

fun loadUserProfile() {
    lifecycleScope.launch {
        val userDeferred = async { fetchUserData() }
        val postsDeferred = async { fetchUserPosts() }
        
        val user = userDeferred.await()
        val posts = postsDeferred.await()
        
        // Both operations run concurrently
        updateUI(user, posts)
    }
}
```

## Error Handling

Coroutines use standard try-catch blocks and provide additional mechanisms:

```kotlin
launch {
    try {
        val result = riskyOperation()
        handleSuccess(result)
    } catch (e: Exception) {
        handleError(e)
    }
}
```

### Structured Exception Handling

Using `CoroutineExceptionHandler`:

```kotlin
val handler = CoroutineExceptionHandler { _, exception ->
    println("Caught $exception")
}

val scope = CoroutineScope(Job() + handler)
scope.launch {
    throw Exception("Something went wrong")
}
```

## Cancellation

Coroutines support cooperative cancellation:

```kotlin
val job = launch {
    repeat(1000) { i ->
        if (!isActive) return@launch // Check for cancellation
        delay(100)
        println("Working $i")
    }
}

delay(500)
job.cancel() // Cancel the coroutine
```

## Channels and Flow

### Channels

Channels provide a way for coroutines to communicate:

```kotlin
val channel = Channel<Int>()

launch {
    for (i in 1..5) {
        channel.send(i)
    }
    channel.close()
}

launch {
    for (value in channel) {
        println(value)
    }
}
```

### Flow

Flow is used for asynchronous streams of data:

```kotlin
fun numbersFlow() = flow {
    for (i in 1..3) {
        delay(100)
        emit(i)
    }
}

// Collect the flow
numbersFlow().collect { value ->
    println(value)
}
```

## Android Integration

In Android development, coroutines integrate seamlessly with lifecycle-aware components:

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        lifecycleScope.launch {
            val data = withContext(Dispatchers.IO) {
                // Network call on IO dispatcher
                apiService.fetchData()
            }
            // Back on Main dispatcher
            updateUI(data)
        }
    }
}
```

## Best Practices

1. Use appropriate dispatchers for different types of work
2. Always use structured concurrency with proper scopes
3. Handle cancellation gracefully in long-running operations
4. Prefer `async` over `launch` when you need a result
5. Use `Flow` for streams of data rather than callbacks
6. Avoid `GlobalScope` in production code
7. Use `viewModelScope` and `lifecycleScope` in Android

## Common Patterns

### Sequential vs Concurrent Execution

```kotlin
// Sequential execution (slower)
val user = fetchUser()
val posts = fetchPosts()

// Concurrent execution (faster)
val userDeferred = async { fetchUser() }
val postsDeferred = async { fetchPosts() }
val user = userDeferred.await()
val posts = postsDeferred.await()
```

### Timeout Operations

```kotlin
try {
    val result = withTimeout(5000) {
        longRunningOperation()
    }
} catch (e: TimeoutCancellationException) {
    println("Operation timed out")
}
```

## Getting Started

To use coroutines in your Kotlin project, add the dependency:

```sh
implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3'
```

For Android projects, also add:

```sh
implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3'
```

## Testing Coroutines

Use `runTest` for testing suspend functions:

```kotlin
@Test
fun testSuspendFunction() = runTest {
    val result = mySuspendFunction()
    assertEquals("expected", result)
}
```

## Conclusion

Coroutines revolutionize asynchronous programming in Kotlin by making it more readable and maintainable while providing powerful concurrency primitives. They're essential for modern Kotlin development, especially in Android applications where responsive UIs are crucial.

The key to mastering coroutines is understanding suspension, proper scope management, and choosing the right dispatcher for your use case. Start with simple examples and gradually explore more advanced features like Flow and Channels as you become comfortable with the basics.