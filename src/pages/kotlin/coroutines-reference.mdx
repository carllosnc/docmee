# Kotlin Coroutines Complete Reference Guide

## Table of Contents
1. [Introduction](#introduction)
2. [Core Concepts](#core-concepts)
3. [Coroutine Builders](#coroutine-builders)
4. [Suspend Functions](#suspend-functions)
5. [Coroutine Context and Dispatchers](#coroutine-context-and-dispatchers)
6. [Structured Concurrency](#structured-concurrency)
7. [Exception Handling](#exception-handling)
8. [Channels and Flow](#channels-and-flow)
9. [Synchronization Primitives](#synchronization-primitives)
10. [Testing Coroutines](#testing-coroutines)
11. [Best Practices](#best-practices)
12. [Common Patterns](#common-patterns)

## Introduction

Kotlin coroutines provide a powerful framework for asynchronous programming that allows you to write non-blocking code in a sequential manner. Coroutines are lightweight threads that can be suspended and resumed without blocking the underlying thread.

### Key Benefits
- **Lightweight**: Millions of coroutines can run on a few threads
- **Sequential Code**: Write asynchronous code that looks synchronous
- **Structured Concurrency**: Automatic lifecycle management
- **Cancellation Support**: Built-in cooperative cancellation
- **Exception Safety**: Proper exception propagation

## Core Concepts

### What is a Coroutine?

A coroutine is a computation that can be suspended and resumed later. It's similar to a thread but much more lightweight and managed by the Kotlin runtime rather than the operating system.

```kotlin
// Basic coroutine example
suspend fun fetchUserData(): User {
    delay(1000) // Suspends for 1 second without blocking the thread
    return User("John", "Doe")
}
```

### Suspension Points

Functions marked with `suspend` can be suspended at certain points (suspension points) and resumed later:

```kotlin
suspend fun example() {
    println("Before delay")
    delay(1000) // Suspension point
    println("After delay")
}
```

## Coroutine Builders

Coroutine builders are functions that create and start coroutines.

### runBlocking

Blocks the current thread until completion. Mainly used in main functions and tests.

```kotlin
fun main() = runBlocking {
    delay(1000)
    println("Hello, Coroutines!")
}
```

### launch

Creates a coroutine that runs concurrently with the rest of the code. Returns a `Job`.

```kotlin
val job = GlobalScope.launch {
    delay(1000)
    println("Background task completed")
}
```

### async

Creates a coroutine that can return a result. Returns a `Deferred<T>`.

```kotlin
val deferred = GlobalScope.async {
    delay(1000)
    "Result from async"
}

val result = deferred.await() // Suspends until result is available
```

### Comparison of Builders

```kotlin
fun demonstrateBuilders() = runBlocking {
    // launch - fire and forget
    launch {
        delay(1000)
        println("Launch completed")
    }
    
    // async - compute and return result
    val result = async {
        delay(500)
        "Async result"
    }
    
    println("Result: ${result.await()}")
}
```

## Suspend Functions

Suspend functions are the building blocks of coroutines. They can only be called from other suspend functions or from coroutines.

### Creating Suspend Functions

```kotlin
suspend fun networkCall(): String {
    delay(2000) // Simulate network delay
    return "Data from server"
}

suspend fun processData(data: String): String {
    delay(1000) // Simulate processing
    return "Processed: $data"
}

suspend fun fetchAndProcess(): String {
    val data = networkCall()
    return processData(data)
}
```

### Suspend Function Composition

```kotlin
suspend fun sequentialExecution() {
    val time = measureTimeMillis {
        val data1 = networkCall() // 2 seconds
        val data2 = networkCall() // 2 seconds
        println("Sequential: ${data1}, ${data2}")
    }
    println("Sequential took: ${time}ms") // ~4 seconds
}

suspend fun concurrentExecution() {
    val time = measureTimeMillis {
        val deferred1 = async { networkCall() }
        val deferred2 = async { networkCall() }
        val data1 = deferred1.await()
        val data2 = deferred2.await()
        println("Concurrent: ${data1}, ${data2}")
    }
    println("Concurrent took: ${time}ms") // ~2 seconds
}
```

## Coroutine Context and Dispatchers

### Coroutine Context

`CoroutineContext` defines the context in which a coroutine runs. It includes:
- Job: Controls the lifecycle
- Dispatcher: Determines thread usage
- Exception Handler: Handles uncaught exceptions
- Coroutine Name: For debugging

```kotlin
val context = Job() + Dispatchers.IO + CoroutineName("MyCoroutine")

launch(context) {
    // Coroutine runs with the specified context
}
```

### Dispatchers

Dispatchers determine which thread or thread pool the coroutine runs on.

#### Dispatchers.Main
For UI operations (Android main thread).

```kotlin
launch(Dispatchers.Main) {
    updateUI() // Runs on main thread
}
```

#### Dispatchers.IO
For I/O operations (file, network, database).

```kotlin
launch(Dispatchers.IO) {
    val data = readFromFile() // Runs on IO thread pool
}
```

#### Dispatchers.Default
For CPU-intensive operations.

```kotlin
launch(Dispatchers.Default) {
    val result = heavyComputation() // Runs on background thread pool
}
```

#### Dispatchers.Unconfined
Starts in the caller thread but can resume in any thread.

```kotlin
launch(Dispatchers.Unconfined) {
    println("Before delay: ${Thread.currentThread().name}")
    delay(1000)
    println("After delay: ${Thread.currentThread().name}")
}
```

### withContext

Switch dispatcher for a block of code:

```kotlin
suspend fun fetchUserProfile(): UserProfile = withContext(Dispatchers.IO) {
    // Network call on IO dispatcher
    api.getUserProfile()
}

suspend fun updateUI(profile: UserProfile) = withContext(Dispatchers.Main) {
    // UI update on main thread
    profileView.update(profile)
}
```

## Structured Concurrency

Structured concurrency ensures that all child coroutines complete before their parent completes.

### CoroutineScope

`CoroutineScope` defines the scope for coroutines and manages their lifecycle.

```kotlin
class UserRepository : CoroutineScope {
    private val job = Job()
    override val coroutineContext = Dispatchers.IO + job
    
    fun fetchUsers() = launch {
        // This coroutine is bound to UserRepository's lifecycle
        val users = api.getUsers()
        // Process users
    }
    
    fun cleanup() {
        job.cancel() // Cancels all coroutines in this scope
    }
}
```

### coroutineScope Builder

Creates a scope that suspends until all children complete:

```kotlin
suspend fun fetchAllData() = coroutineScope {
    val users = async { fetchUsers() }
    val posts = async { fetchPosts() }
    val comments = async { fetchComments() }
    
    // All three operations run concurrently
    Triple(users.await(), posts.await(), comments.await())
}
```

### supervisorScope

Similar to `coroutineScope` but failure of one child doesn't cancel others:

```kotlin
suspend fun fetchDataWithFallback() = supervisorScope {
    val primaryData = async { fetchPrimaryData() }
    val fallbackData = async { fetchFallbackData() }
    
    try {
        primaryData.await()
    } catch (e: Exception) {
        fallbackData.await()
    }
}
```

## Exception Handling

### Exception Propagation

Exceptions in coroutines follow structured concurrency rules:

```kotlin
runBlocking {
    try {
        launch {
            throw Exception("Child exception")
        }
    } catch (e: Exception) {
        // This won't catch the exception
        println("Caught: ${e.message}")
    }
}
```

### CoroutineExceptionHandler

Handle uncaught exceptions:

```kotlin
val exceptionHandler = CoroutineExceptionHandler { context, exception ->
    println("Caught exception: ${exception.message}")
}

val scope = CoroutineScope(Dispatchers.IO + exceptionHandler)

scope.launch {
    throw Exception("Unhandled exception")
} // Exception will be handled by exceptionHandler
```

### Exception Handling Patterns

```kotlin
// Pattern 1: try-catch in coroutine
launch {
    try {
        riskyOperation()
    } catch (e: Exception) {
        handleException(e)
    }
}

// Pattern 2: Exception handling with async
val deferred = async {
    riskyOperation()
}

try {
    val result = deferred.await()
} catch (e: Exception) {
    handleException(e)
}

// Pattern 3: Using supervisorScope
supervisorScope {
    val job1 = launch { mayFail() }
    val job2 = launch { alsoMayFail() }
    
    // If job1 fails, job2 continues
}
```

## Channels and Flow

### Channels

Channels provide communication between coroutines:

```kotlin
fun CoroutineScope.produceNumbers() = produce<Int> {
    var x = 1
    while (true) {
        send(x++) // Send next number
        delay(100)
    }
}

fun main() = runBlocking {
    val numbers = produceNumbers()
    repeat(5) {
        println(numbers.receive()) // Receive numbers
    }
    numbers.cancel()
}
```

### Channel Types

```kotlin
// Unlimited capacity
val unlimited = Channel<Int>(Channel.UNLIMITED)

// Buffered channel
val buffered = Channel<Int>(10)

// Rendezvous channel (default)
val rendezvous = Channel<Int>()

// Conflated channel (keeps only latest)
val conflated = Channel<Int>(Channel.CONFLATED)
```

### Flow

Flow is a stream of values that can be computed asynchronously:

```kotlin
fun simpleFlow() = flow {
    for (i in 1..3) {
        delay(100)
        emit(i) // Emit values
    }
}

fun main() = runBlocking {
    simpleFlow().collect { value ->
        println("Received: $value")
    }
}
```

### Flow Operators

```kotlin
fun main() = runBlocking {
    flow {
        for (i in 1..10) {
            emit(i)
        }
    }
    .filter { it % 2 == 0 } // Filter even numbers
    .map { it * it }        // Square them
    .take(3)                // Take first 3
    .collect { println(it) } // Collect and print
}
```

### StateFlow and SharedFlow

```kotlin
class CounterViewModel : ViewModel() {
    private val _counter = MutableStateFlow(0)
    val counter: StateFlow<Int> = _counter.asStateFlow()
    
    private val _events = MutableSharedFlow<String>()
    val events: SharedFlow<String> = _events.asSharedFlow()
    
    fun increment() {
        _counter.value += 1
        _events.tryEmit("Counter incremented")
    }
}
```

## Synchronization Primitives

### Mutex

Mutual exclusion for protecting shared mutable state:

```kotlin
val mutex = Mutex()
var counter = 0

suspend fun incrementCounter() {
    mutex.withLock {
        counter++
    }
}
```

### Semaphore

Control access to a resource with limited capacity:

```kotlin
val semaphore = Semaphore(permits = 3)

suspend fun accessResource() {
    semaphore.withPermit {
        // Only 3 coroutines can access this block simultaneously
        processResource()
    }
}
```

### Atomic Operations

```kotlin
val atomicCounter = AtomicInteger(0)

fun incrementAtomic() {
    atomicCounter.incrementAndGet()
}
```

## Testing Coroutines

### TestCoroutineDispatcher (Deprecated)

```kotlin
@Test
fun testCoroutine() = runBlockingTest {
    val result = async {
        delay(1000)
        "Test result"
    }
    
    advanceTimeBy(1000)
    assertEquals("Test result", result.await())
}
```

### Modern Testing with runTest

```kotlin
@Test
fun testWithRunTest() = runTest {
    val result = async {
        delay(1000)
        "Test result"
    }
    
    // Time is automatically advanced
    assertEquals("Test result", result.await())
}
```

### Testing Flow

```kotlin
@Test
fun testFlow() = runTest {
    val flow = flow {
        emit(1)
        delay(1000)
        emit(2)
    }
    
    val result = flow.toList()
    assertEquals(listOf(1, 2), result)
}
```

## Best Practices

### 1. Use Structured Concurrency

```kotlin
// Good: Use proper scope
class MyRepository(private val scope: CoroutineScope) {
    fun loadData() = scope.launch {
        // Coroutine tied to scope lifecycle
    }
}

// Bad: Using GlobalScope
fun loadData() = GlobalScope.launch {
    // Hard to control lifecycle
}
```

### 2. Handle Cancellation

```kotlin
suspend fun longRunningTask() {
    for (i in 1..1000) {
        ensureActive() // Check if coroutine is still active
        // Do work
        yield() // Cooperative cancellation point
    }
}
```

### 3. Use Appropriate Dispatchers

```kotlin
// Good: Use specific dispatchers
suspend fun saveToDatabase(data: Data) = withContext(Dispatchers.IO) {
    database.save(data)
}

suspend fun updateUI(data: Data) = withContext(Dispatchers.Main) {
    view.update(data)
}

// Bad: Wrong dispatcher usage
suspend fun heavyComputation() = withContext(Dispatchers.Main) {
    // This blocks the UI thread
    performHeavyWork()
}
```

### 4. Avoid Memory Leaks

```kotlin
class MyActivity : AppCompatActivity() {
    private val job = Job()
    private val scope = CoroutineScope(Dispatchers.Main + job)
    
    override fun onDestroy() {
        super.onDestroy()
        job.cancel() // Cancel all coroutines
    }
}
```

## Common Patterns

### 1. Timeout Pattern

```kotlin
suspend fun fetchWithTimeout(): String? = try {
    withTimeout(5000) {
        networkCall()
    }
} catch (e: TimeoutCancellationException) {
    null
}
```

### 2. Retry Pattern

```kotlin
suspend fun <T> retry(
    times: Int = 3,
    delay: Long = 1000,
    block: suspend () -> T
): T {
    repeat(times - 1) {
        try {
            return block()
        } catch (e: Exception) {
            delay(delay)
        }
    }
    return block() // Last attempt
}
```

### 3. Parallel Processing

```kotlin
suspend fun processInParallel(items: List<Item>): List<Result> = 
    items.map { item ->
        async { processItem(item) }
    }.awaitAll()
```

### 4. Rate Limiting

```kotlin
class RateLimiter(private val permits: Int, private val period: Duration) {
    private val semaphore = Semaphore(permits)
    private val resetTime = AtomicLong(0)
    
    suspend fun acquire() {
        val now = System.currentTimeMillis()
        val reset = resetTime.get()
        
        if (now > reset) {
            resetTime.compareAndSet(reset, now + period.inWholeMilliseconds)
            // Reset available permits
        }
        
        semaphore.acquire()
    }
}
```

### 5. Circuit Breaker Pattern

```kotlin
class CircuitBreaker(
    private val failureThreshold: Int = 5,
    private val timeout: Duration = Duration.seconds(60)
) {
    private enum class State { CLOSED, OPEN, HALF_OPEN }
    
    private var state = State.CLOSED
    private var failureCount = 0
    private var lastFailureTime = 0L
    
    suspend fun <T> execute(operation: suspend () -> T): T {
        when (state) {
            State.OPEN -> {
                if (System.currentTimeMillis() - lastFailureTime > timeout.inWholeMilliseconds) {
                    state = State.HALF_OPEN
                } else {
                    throw CircuitBreakerException("Circuit breaker is OPEN")
                }
            }
            State.HALF_OPEN -> {
                // Allow one test call
            }
            State.CLOSED -> {
                // Normal operation
            }
        }
        
        return try {
            val result = operation()
            onSuccess()
            result
        } catch (e: Exception) {
            onFailure()
            throw e
        }
    }
    
    private fun onSuccess() {
        failureCount = 0
        state = State.CLOSED
    }
    
    private fun onFailure() {
        failureCount++
        lastFailureTime = System.currentTimeMillis()
        if (failureCount >= failureThreshold) {
            state = State.OPEN
        }
    }
}
```

## Conclusion

Kotlin coroutines provide a powerful and elegant solution for asynchronous programming. Key takeaways:

- Use structured concurrency for proper lifecycle management
- Choose appropriate dispatchers for different types of work
- Handle exceptions properly with try-catch and exception handlers
- Use Flow for reactive streams of data
- Apply proper testing strategies with runTest
- Follow best practices to avoid common pitfalls

By mastering these concepts and patterns, you can write efficient, maintainable, and robust asynchronous code in Kotlin.