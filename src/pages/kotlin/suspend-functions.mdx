---
layout: ../../layout/main-layout.astro
---
<a href="/kotlin">← Kotlin</a> <br /> <br />

# Suspend Functions

## Overview

Suspend functions are the foundation of Kotlin coroutines, enabling asynchronous programming without blocking threads. They can be paused and resumed at suspension points, allowing other coroutines to execute on the same thread.

## Basic Syntax

### Declaration
```kotlin
suspend fun fetchData(): String {
    delay(1000) // Suspension point
    return "Data fetched"
}
```

### Calling Suspend Functions
Suspend functions can only be called from:
- Other suspend functions
- Coroutine builders (`launch`, `async`, `runBlocking`)
- Coroutine scope

```kotlin
// ✅ Valid - from another suspend function
suspend fun processData(): String {
    return fetchData() // Can call suspend function
}

// ✅ Valid - from coroutine builder
fun main() {
    runBlocking {
        val data = fetchData() // Can call suspend function
    }
}

// ❌ Invalid - from regular function
fun regularFunction() {
    val data = fetchData() // Compilation error
}
```

## Suspension Points

### Common Suspension Points
- `delay(millis)` - Non-blocking delay
- `yield()` - Cooperative yielding
- Network calls (with suspend APIs)
- File I/O operations (with suspend APIs)
- Other suspend function calls

```kotlin
suspend fun exampleSuspensions() {
    delay(100)           // Suspends for 100ms
    yield()              // Yields execution to other coroutines
    
    // Custom suspension points
    suspendCoroutine { continuation ->
        // Custom async operation
        continuation.resume("Result")
    }
}
```

## Coroutine Builders

### launch
Creates a coroutine that doesn't return a result.

```kotlin
fun main() {
    runBlocking {
        launch {
            println("Launch: ${fetchData()}")
        }
        
        launch(Dispatchers.IO) {
            // Runs on IO dispatcher
            println("IO: ${fetchData()}")
        }
    }
}
```

### async
Creates a coroutine that returns a `Deferred<T>` result.

```kotlin
suspend fun concurrentFetch(): List<String> {
    val deferred1 = async { fetchData() }
    val deferred2 = async { fetchData() }
    
    return listOf(deferred1.await(), deferred2.await())
}
```

### runBlocking
Blocks the current thread until completion (mainly for main functions and tests).

```kotlin
fun main() = runBlocking {
    val result = fetchData()
    println(result)
}
```

## Coroutine Scope

### CoroutineScope Interface
```kotlin
class MyClass : CoroutineScope {
    override val coroutineContext: CoroutineContext = 
        SupervisorJob() + Dispatchers.Main
    
    fun startWork() {
        launch {
            val data = fetchData()
            // Process data
        }
    }
    
    fun cleanup() {
        coroutineContext.cancelChildren()
    }
}
```

### Structured Concurrency
```kotlin
suspend fun structuredExample() = coroutineScope {
    val job1 = async { fetchData() }
    val job2 = async { fetchData() }
    
    // Both jobs complete before function returns
    listOf(job1.await(), job2.await())
}
```

## Dispatchers

### Available Dispatchers
```kotlin
suspend fun dispatcherExamples() {
    // Main thread (UI operations)
    withContext(Dispatchers.Main) {
        updateUI()
    }
    
    // Background thread pool (CPU-intensive work)
    withContext(Dispatchers.Default) {
        performCalculation()
    }
    
    // I/O optimized thread pool
    withContext(Dispatchers.IO) {
        readFromFile()
    }
    
    // Current thread (no thread switch)
    withContext(Dispatchers.Unconfined) {
        quickOperation()
    }
}
```

## Exception Handling

### try-catch with Suspend Functions
```kotlin
suspend fun handleExceptions(): String? {
    return try {
        fetchData()
    } catch (e: Exception) {
        println("Error: ${e.message}")
        null
    }
}
```

### Exception Propagation
```kotlin
suspend fun exceptionPropagation() = coroutineScope {
    try {
        async {
            throw RuntimeException("Error in async")
        }.await()
    } catch (e: Exception) {
        println("Caught: ${e.message}")
    }
}
```

### SupervisorJob for Independent Failures
```kotlin
suspend fun supervisorExample() = supervisorScope {
    val job1 = async {
        delay(1000)
        throw RuntimeException("Job1 failed")
    }
    
    val job2 = async {
        delay(2000)
        "Job2 success"
    }
    
    // job1 failure doesn't cancel job2
    try {
        job1.await()
    } catch (e: Exception) {
        println("Job1 failed: ${e.message}")
    }
    
    println("Job2 result: ${job2.await()}")
}
```

## Cancellation

### Checking for Cancellation
```kotlin
suspend fun cancellableWork() {
    repeat(1000) { i ->
        // Check if coroutine is cancelled
        ensureActive()
        // or
        if (!isActive) return
        
        // Do work
        performStep(i)
        delay(100)
    }
}
```

### Cancellation with finally
```kotlin
suspend fun cleanupExample() {
    try {
        repeat(1000) {
            delay(100)
            println("Working...")
        }
    } finally {
        // Cleanup code
        println("Cleaning up...")
    }
}
```

## Flow Integration

### Creating Flows with Suspend Functions
```kotlin
fun createFlow(): Flow<String> = flow {
    repeat(5) { i ->
        emit(fetchData())
        delay(1000)
    }
}

suspend fun collectFlow() {
    createFlow().collect { value ->
        println("Received: $value")
    }
}
```

## Advanced Patterns

### Custom Suspend Functions
```kotlin
suspend fun <T> withTimeout(timeoutMs: Long, block: suspend () -> T): T {
    return withTimeoutOrNull(timeoutMs) { block() }
        ?: throw TimeoutException("Operation timed out")
}

suspend fun customSuspendCoroutine(): String = suspendCoroutine { cont ->
    // Simulate async operation
    Thread {
        Thread.sleep(1000)
        cont.resume("Custom result")
    }.start()
}
```

### Suspend Function Composition
```kotlin
suspend fun pipeline(): String {
    val step1 = async { fetchData() }
    val step2 = async { processData(step1.await()) }
    val step3 = async { saveData(step2.await()) }
    
    return step3.await()
}

suspend fun processData(data: String): String {
    delay(500)
    return data.uppercase()
}

suspend fun saveData(data: String): String {
    delay(300)
    println("Saved: $data")
    return data
}
```

## Testing Suspend Functions

### Using runTest
```kotlin
@Test
fun testSuspendFunction() = runTest {
    val result = fetchData()
    assertEquals("Data fetched", result)
}
```

### Testing with TestDispatchers
```kotlin
@Test
fun testWithTestDispatcher() = runTest {
    val testDispatcher = StandardTestDispatcher()
    
    launch(testDispatcher) {
        val result = fetchData()
        println(result)
    }
    
    advanceUntilIdle() // Complete all pending coroutines
}
```

## Best Practices

### 1. Prefer suspend functions over callbacks
```kotlin
// ❌ Callback style
fun fetchDataCallback(callback: (String) -> Unit) {
    // Implementation
}

// ✅ Suspend function style
suspend fun fetchData(): String {
    // Implementation
}
```

### 2. Use appropriate dispatchers
```kotlin
suspend fun properDispatcherUsage() {
    // CPU-intensive work
    val result = withContext(Dispatchers.Default) {
        heavyComputation()
    }
    
    // UI update
    withContext(Dispatchers.Main) {
        updateUI(result)
    }
    
    // Network/File I/O
    val data = withContext(Dispatchers.IO) {
        fetchFromNetwork()
    }
}
```

### 3. Handle cancellation properly
```kotlin
suspend fun cancellationAwareWork() {
    try {
        repeat(100) { index ->
            ensureActive() // Check for cancellation
            performWork(index)
            delay(100)
        }
    } catch (e: CancellationException) {
        // Cleanup if needed
        cleanup()
        throw e // Re-throw to maintain cancellation
    }
}
```

### 4. Use structured concurrency
```kotlin
suspend fun structuredWork() = coroutineScope {
    // All child coroutines complete before this function returns
    val results = List(10) { index ->
        async {
            fetchData()
        }
    }.awaitAll()
    
    processResults(results)
}
```

## Common Suspend Functions in Kotlin Standard Library

### kotlinx.coroutines
- `delay(timeMillis: Long)`
- `yield()`
- `withContext(context: CoroutineContext, block: suspend CoroutineScope.() -> T)`
- `withTimeout(timeoutMillis: Long, block: suspend CoroutineScope.() -> T)`
- `withTimeoutOrNull(timeoutMillis: Long, block: suspend CoroutineScope.() -> T)`
- `coroutineScope(block: suspend CoroutineScope.() -> R)`
- `supervisorScope(block: suspend CoroutineScope.() -> R)`

### Flow Operations
- `Flow<T>.collect(collector: FlowCollector<T>)`
- `Flow<T>.map(transform: suspend (T) -> R)`
- `Flow<T>.filter(predicate: suspend (T) -> Boolean)`
- `Flow<T>.first()`, `Flow<T>.last()`, `Flow<T>.single()`

## Performance Considerations

### 1. Avoid blocking operations in suspend functions
```kotlin
// ❌ Don't block in suspend functions
suspend fun badExample(): String {
    Thread.sleep(1000) // Blocks the thread!
    return "Result"
}

// ✅ Use proper suspend functions
suspend fun goodExample(): String {
    delay(1000) // Suspends without blocking
    return "Result"
}
```

### 2. Consider using Sequences for CPU-bound work
```kotlin
suspend fun processLargeDataset(data: List<Int>): List<Int> {
    return withContext(Dispatchers.Default) {
        data.asSequence()
            .map { heavyComputation(it) }
            .filter { it > 0 }
            .toList()
    }
}
```

This reference covers the essential aspects of suspend functions in Kotlin. Remember that suspend functions are the building blocks of coroutines and enable writing asynchronous code that looks and feels like synchronous code while being non-blocking and efficient.