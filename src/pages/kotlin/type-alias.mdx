---
layout: ../../layout/main-layout.astro
---
<a href="/kotlin">‚Üê Kotlin</a> <br /> <br />

# Type Alias

## Introduction

Type aliases in Kotlin provide a way to give alternative names to existing types, improving code readability and maintainability. They do not create new types but serve as shorthand references to complex or lengthy type definitions. Introduced in Kotlin 1.1, type aliases are particularly useful for simplifying function types, generic types, or long class names.

This document provides a comprehensive reference for type aliases in Kotlin, including syntax, use cases, limitations, and examples.

## Syntax

The `typealias` keyword is used to define a type alias. The basic syntax is:

```kotlin
typealias NewName = ExistingType
```

- `NewName`: The alias name you define.
- `ExistingType`: The original type being aliased, which can be a class, interface, primitive type, function type, or generic type.

Type aliases can be declared at the top level of a file, within a class, or inside an object.

## Key Characteristics

- **No New Type Creation**: Type aliases are purely syntactic sugar. The alias is interchangeable with the original type during compilation.
- **Scope**: Type aliases respect Kotlin's scoping rules. A type alias declared inside a class is only visible within that class unless marked `public`.
- **Interoperability**: Type aliases are erased at runtime, so they do not affect Java interoperability or reflection.
- **Not Recursive**: Type aliases cannot be recursive (e.g., a type alias cannot reference itself directly or indirectly).

## Use Cases

### 1. Simplifying Complex Function Types

Type aliases are commonly used to simplify function types, especially for higher-order functions or lambdas.

```kotlin
typealias ClickHandler = (View, Event) -> Unit

fun setOnClickListener(handler: ClickHandler) {
    // Use handler as a function type
}
```

### 2. Shortening Long Class Names

For classes with long or nested names, type aliases provide a shorter, more readable alternative.

```kotlin
typealias UserMap = Map<String, com.example.model.UserProfile>

val users: UserMap = mapOf("id1" to UserProfile("Alice"))
```

### 3. Improving Readability of Generic Types

Type aliases can make generic types more expressive and concise.

```kotlin
typealias ResultList<T> = List<Result<T>>

val results: ResultList<String> = listOf(Result.success("data"))
```

### 4. Domain-Specific Naming

Type aliases can give domain-specific meaning to primitive or common types.

```kotlin
typealias UserId = String
typealias Money = BigDecimal

fun processPayment(userId: UserId, amount: Money) {
    // Process payment
}
```

### 5. Function Type with Receivers

Type aliases can represent function types with receivers (extension-like functions).

```kotlin
typealias StringTransformer = String.() -> String

val upperCase: StringTransformer = { this.toUpperCase() }
val result = "hello".upperCase() // Outputs: HELLO
```

## Examples

### Example 1: Simplifying a Function Type

```kotlin
typealias Operation = (Int, Int) -> Int

fun calculate(a: Int, b: Int, op: Operation): Int {
    return op(a, b)
}

val sum: Operation = { x, y -> x + y }
val product: Operation = { x, y -> x * y }

fun main() {
    println(calculate(5, 3, sum))     // Outputs: 8
    println(calculate(5, 3, product)) // Outputs: 15
}
```

### Example 2: Aliasing a Generic Type

```kotlin
typealias StringSet = Set<String>

fun printItems(items: StringSet) {
    items.forEach { println(it) }
}

fun main() {
    val names: StringSet = setOf("Alice", "Bob")
    printItems(names) // Outputs: Alice, Bob
}
```

### Example 3: Nested Type Alias in a Class

```kotlin
class Database {
    typealias QueryResult = List<Map<String, Any>>

    fun executeQuery(query: String): QueryResult {
        // Simulate query execution
        return listOf(mapOf("id" to 1, "name" to "Alice"))
    }
}

fun main() {
    val db = Database()
    val result: Database.QueryResult = db.executeQuery("SELECT * FROM users")
    println(result) // Outputs: [{id=1, name=Alice}]
}
```

## Limitations

1. **No Type Safety**: Type aliases do not create distinct types, so they cannot be used to enforce type safety. For example:

```kotlin
typealias UserId = String
typealias OrderId = String

fun processUser(id: UserId) {}
fun processOrder(id: OrderId) {}

fun main() {
    val userId: UserId = "123"
    processOrder(userId) // No error, as UserId and OrderId are both String
}
```

To enforce type safety, consider using `value class` or `sealed class`.

2. **No Runtime Representation**: Type aliases are erased at compile-time, so they cannot be used in reflection or runtime type checks.

3. **No Type Parameter Constraints**: Type aliases cannot directly impose constraints on generic type parameters. Use interfaces or classes for such cases.

```kotlin
// Invalid: Type alias cannot constrain T
typealias ConstrainedList<T : Number> = List<T> // Compilation error
```

4. **Visibility Modifiers**: Type aliases support visibility modifiers (`private`, `internal`, etc.), but they must align with the containing scope.

```kotlin
class Example {
    private typealias InternalId = Int // Only visible within Example
}
```

## Best Practices

- **Use Descriptive Names**: Choose alias names that clearly convey intent or domain-specific meaning (e.g., `UserId` instead of `Id`).
- **Avoid Overuse**: Use type aliases sparingly to avoid cluttering the codebase with unnecessary abstractions.
- **Combine with Other Features**: Pair type aliases with Kotlin's type system features (e.g., extension functions) for expressive APIs.
- **Document Intent**: Add KDoc comments to type aliases to explain their purpose, especially in public APIs.

```kotlin
/**
 * Represents a unique identifier for a user in the system.
 */
typealias UserId = String
```

## Comparison with Other Features

| Feature          | Type Alias                        | Value Class                     | Interface/Class                  |
|------------------|-----------------------------------|----------------------------------|----------------------------------|
| Creates New Type | No (alias only)                  | Yes                              | Yes                              |
| Runtime Overhead | None (erased at compile-time)    | Minimal (inlined when possible) | Full (new type with instances)   |
| Type Safety      | No                               | Yes                              | Yes                              |
| Use Case         | Simplify type names              | Lightweight wrappers             | Complex type hierarchies         |

### Example: Type Alias vs. Value Class

```kotlin
// Type Alias
typealias UserId = String

// Value Class
@JvmInline
value class UserId(val value: String)

fun processUser(id: UserId) {}

fun main() {
    val id = "123"
    processUser(id) // Works with type alias, fails with value class unless wrapped
}
```

## Common Pitfalls

- **Misusing for Type Safety**: Using type aliases when distinct types are needed can lead to bugs, as aliases are interchangeable.
- **Overcomplicating APIs**: Excessive use of type aliases can make code harder to understand if the aliases obscure the underlying types.
- **Confusing Java Interoperability**: In Java, type aliases are not visible, so the original type is used, which may confuse Java developers.

## Interoperability with Java

When calling Kotlin code from Java, type aliases are resolved to their underlying types. For example:

```kotlin
// Kotlin
typealias UserId = String
fun getUser(id: UserId) = "User: $id"
```

```java
// Java
String user = MyKotlinClass.getUser("123"); // UserId is seen as String
```

## Since Kotlin Version

- Type aliases were introduced in **Kotlin 1.1**.
- No significant changes to type alias functionality have been made in later versions up to Kotlin 2.0.

## Official Documentation

For the most authoritative and up-to-date information, refer to the [Kotlin official documentation on type aliases](https://kotlinlang.org/docs/type-aliases.html).