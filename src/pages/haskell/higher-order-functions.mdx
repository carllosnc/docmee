---
layout: ../../layout/main-layout.astro
---
<a href="/haskell">← Haskell</a> <br /> <br />

# Higher-Order Functions

## Overview of Higher-Order Functions

Higher-order functions leverage Haskell’s functional nature by treating functions as values. They are commonly used with lists (e.g., `map`, `filter`) and support currying, lazy evaluation, and type polymorphism. They simplify code by abstracting repetitive patterns, such as applying a transformation to a list or composing functions.

### Basic Syntax
```haskell
functionName :: (Type1 -> Type2) -> Type3 -> ReturnType
functionName f param = expression
```
- **Type Signature**: Includes a function type (e.g., `a -> b`) as a parameter or return type.
- **Function Parameter**: A function `f` passed as an argument.
- **Expression**: Uses the function parameter in computations.

## 1. Map: Transforming a List
Apply a function to each element in a list.

```haskell
-- map.hs
-- Doubles each number in a list.

doubleList :: [Int] -> [Int]
doubleList xs = map (*2) xs

main :: IO ()
main = print (doubleList [1, 2, 3])  -- Outputs: [2,4,6]
```

- **Description**: `map` applies the function `(*2)` to each element of `xs`.
- **Key Concept**: `map :: (a -> b) -> [a] -> [b]` transforms lists using a function.
- **In GHCi**: `map (+1) [1,2,3]` returns `[2,3,4]`.

## 2. Filter: Selecting Elements
Select elements from a list based on a predicate.

```haskell
-- filter.hs
-- Filters even numbers from a list.

evens :: [Int] -> [Int]
evens xs = filter even xs

main :: IO ()
main = print (evens [1, 2, 3, 4, 5])  -- Outputs: [2,4]
```

- **Description**: `filter` uses the predicate `even` to keep even numbers.
- **Key Concept**: `filter :: (a -> Bool) -> [a] -> [a]` selects elements where the function returns `True`.
- **In GHCi**: `filter (>3) [1..5]` returns `[4,5]`.

## 3. Fold (Reduce): Aggregating a List
Combine list elements using a function.

```haskell
-- fold.hs
-- Sums a list using foldr.

sumList :: [Int] -> Int
sumList xs = foldr (+) 0 xs

main :: IO ()
main = print (sumList [1, 2, 3, 4])  -- Outputs: 10
```

- **Description**: `foldr` applies `(+)` right-to-left, starting with `0`.
- **Key Concept**: `foldr :: (a -> b -> b) -> b -> [a] -> b` reduces a list to a single value.
- **In GHCi**: `foldr (*) 1 [1..3]` returns `6` (1 * 2 * 3).

## 4. Apply Twice: Repeated Function Application
Apply a function multiple times to a value.

```haskell
-- applytwice.hs
-- Applies a function twice to a value.

applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)

main :: IO ()
main = print (applyTwice (+1) 5)  -- Outputs: 7
```

- **Description**: `applyTwice` applies `f` to `x`, then applies `f` again to the result.
- **Key Concept**: Higher-order functions can abstract repetitive function calls.
- **In GHCi**: `applyTwice (*2) 3` returns `12` (3 * 2 = 6, 6 * 2 = 12).

## 5. Function Composition: Chaining Functions
Combine functions to create a new function.

```haskell
-- compose.hs
-- Negates the square of a number.

negateSquare :: Int -> Int
negateSquare = negate . (^2)

main :: IO ()
main = print (negateSquare 3)  -- Outputs: -9
```

- **Description**: Composes `negate` and `(^2)` to compute `-(x^2)`.
- **Key Concept**: `(.) :: (b -> c) -> (a -> b) -> a -> c` chains functions: `(f . g) x = f (g x)`.
- **In GHCi**: `(negate . (*10)) 5` returns `-50`.

## 6. Lambda with Higher-Order: Inline Functions
Use lambdas as arguments to higher-order functions.

```haskell
-- lambda.hs
-- Squares odd numbers in a list.

squareOdds :: [Int] -> [Int]
squareOdds xs = map (\x -> if odd x then x * x else x) xs

main :: IO ()
main = print (squareOdds [1, 2, 3, 4])  -- Outputs: [1,2,9,4]
```

- **Description**: Uses a lambda to square only odd numbers.
- **Key Concept**: Lambdas provide inline functions for `map`, `filter`, etc.
- **In GHCi**: `map (\x -> x + 2) [1,2]` returns `[3,4]`.

## 7. Currying with Higher-Order: Partial Application
Combine currying with higher-order functions.

```haskell
-- curry_map.hs
-- Adds a constant to each list element.

addToList :: Int -> [Int] -> [Int]
addToList n xs = map (+n) xs

main :: IO ()
main = print (addToList 5 [1, 2, 3])  -- Outputs: [6,7,8]
```

- **Description**: `(+n)` is a partially applied function used with `map`.
- **Key Concept**: Currying enables concise function arguments.
- **In GHCi**: `addToList 10 [1,2]` returns `[11,12]`.

## 8. Filter and Map Combined: Process Strings
Use multiple higher-order functions together.

```haskell
-- process_string.hs
-- Capitalizes short words (length < 4).

capitalizeShort :: [String] -> [String]
capitalizeShort xs = map (\s -> if length s < 4 then map toUpper s else s) xs

main :: IO ()
main = print (capitalizeShort ["hi", "haskell", "ok"])  -- Outputs: ["HI","haskell","OK"]
```

- **Description**: `map` applies a conditional transformation, using `toUpper` from `Data.Char`.
- **Key Concept**: Combine `map`, `filter`, etc., for complex transformations. Requires `import Data.Char`.
- **In GHCi**: `capitalizeShort ["a", "long"]` returns `["A","long"]`.

## 9. I/O with Higher-Order: Configurable Output
Use higher-order functions in `IO` actions.

```haskell
-- io_map.hs
-- Applies a function to user input.

processInput :: (String -> String) -> IO ()
processInput f = do
  putStrLn "Enter text:"
  text <- getLine
  putStrLn (f text)

main :: IO ()
main = processInput (map toUpper)  -- Outputs: uppercase input
```

- **Description**: `processInput` takes a function to transform user input. Uses `map toUpper` to capitalize.
- **Key Concept**: Higher-order functions work in `IO` for flexible processing. Requires `import Data.Char`.
- **How to Run**: Compile and run; enter text when prompted.

## 10. Module with Higher-Order Functions: Utilities
Organize higher-order functions in a module.

```haskell
-- ListUtils.hs
module ListUtils (transformList, select) where

transformList :: (a -> b) -> [a] -> [b]
transformList = map

select :: (a -> Bool) -> [a] -> [a]
select = filter
```

- **Description**: Exports `transformList` (alias for `map`) and `select` (alias for `filter`). Import with `import ListUtils`.
- **Usage Example** in another file:
  ```haskell
  import ListUtils
  main = print (transformList (+1) [1,2,3])  -- Outputs: [2,3,4]
  ```
- **Key Concept**: Modules encapsulate reusable higher-order functions.

## Characteristics of Higher-Order Functions
- **First-Class Functions**: Functions can be passed as arguments or returned.
- **Purity**: Pure functions ensure predictable behavior when used as arguments.
- **Type Polymorphism**: Many higher-order functions (e.g., `map`, `filter`) are generic, using type variables like `a -> b`.
- **Lazy Evaluation**: Only evaluates arguments when needed, enabling efficient processing (e.g., `take 5 (map (+1) [1..])`).
- **Abstraction**: Reduces boilerplate by generalizing patterns like iteration or transformation.

## Best Practices
- **Use Type Signatures**: Specify function types (e.g., `(a -> b) -> [a] -> [b]`) for clarity.
- **Leverage Prelude Functions**: Use `map`, `filter`, `foldr`, `foldl` for common tasks.
- **Combine Functions**: Chain higher-order functions (e.g., `map f . filter p`) for concise code.
- **Test in GHCi**: Experiment with function applications (e.g., `:t map`, `map (*2) [1,2]`).
- **Descriptive Names**: Choose names like `transformList` to reflect purpose.

## Additional Tips
- **Error Handling**: Use `Maybe` in higher-order functions for safety, e.g., `safeMap f xs = map (\x -> maybe x f x) xs`.
- **Common Functions**: Explore `Prelude` (e.g., `foldr`, `foldl1`, `scanl`) and `Data.List` (e.g., `group`, `sort`).
- **Debugging**: Use `trace` from `Debug.Trace` sparingly to inspect outputs.
- **Practice**: Solve problems on [Exercism Haskell Track](https://exercism.org/tracks/haskell) or [HackerRank Functional Programming](https://www.hackerrank.com/domains/functional-programming).

## Resources
- [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/) (free, covers higher-order functions).
- [Haskell Documentation](https://www.haskell.org/documentation/) for official guides.
- [Hackage](https://hackage.haskell.org/) for `Prelude` and `Data.List` documentation.