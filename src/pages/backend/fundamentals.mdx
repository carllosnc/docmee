---
layout: ../../layout/main-layout.astro
---
<a href="/backend">← Backend</a> <br /> <br />

# Fundamentals

## 1. How the Server Works (Request–Response Cycle)

The request-response cycle is the fundamental communication pattern between clients and servers in web applications.

### The Basic Flow

When a user interacts with a web application, the following sequence occurs:

1. **Client Initiates Request**: The client (browser, mobile app, or another service) sends an HTTP request to the server. This request contains information about what the client wants, including the URL, HTTP method, headers, and optionally a body with data.

2. **Server Receives Request**: The server's web framework (Express, Django, Spring, etc.) receives the incoming request and begins processing it.

3. **Request Processing**: The server executes the appropriate handler or controller based on the request URL and method. This may involve parsing request data, validating inputs, querying databases, calling external APIs, or performing business logic.

4. **Response Generation**: The server constructs an HTTP response containing a status code, headers, and a body (typically JSON, HTML, or XML).

5. **Client Receives Response**: The response travels back to the client, which then processes and displays the data to the user.

### Key Components

**HTTP Request Structure:**

- Request Line: Method, URL, HTTP version
- Headers: Metadata about the request (content type, authorization, etc.)
- Body: Data sent to the server (for POST, PUT, PATCH requests)

**HTTP Response Structure:**

- Status Line: HTTP version, status code, status message
- Headers: Metadata about the response (content type, cache control, etc.)
- Body: The actual data being returned (JSON, HTML, files, etc.)

### Server Architecture Patterns

**Single-Threaded Event Loop** (Node.js): Handles multiple requests concurrently using asynchronous I/O operations without creating multiple threads.

**Multi-Threaded** (Java, Python with threading): Creates separate threads to handle concurrent requests, allowing parallel processing of CPU-intensive tasks.

**Multi-Process** (Python with Gunicorn/uWSGI): Spawns multiple worker processes to handle requests in parallel, providing better CPU utilization and fault isolation.

---

## 2. REST API Design Principles

REST (Representational State Transfer) is an architectural style for designing networked applications, primarily used for building web APIs.

### Core REST Principles

**Client-Server Architecture**: The client and server are separate entities that communicate over a network. The client handles the user interface and user experience, while the server manages data storage and business logic.

**Statelessness**: Each request from the client must contain all information necessary to understand and process the request. The server doesn't store client context between requests. Any session state is kept entirely on the client.

**Cacheability**: Responses must define themselves as cacheable or non-cacheable to prevent clients from reusing stale data. This improves performance and scalability.

**Uniform Interface**: REST APIs follow consistent patterns for resource manipulation, making them predictable and easy to use.

**Layered System**: The architecture can be composed of hierarchical layers, with each layer providing services to the layer above it and using services from the layer below.

### REST API Design Best Practices

**Resource-Based URLs**: Structure URLs around resources (nouns), not actions (verbs).

```
Good: GET /users/123
Bad: GET /getUser?id=123

Good: POST /orders
Bad: POST /createOrder
```

**Use HTTP Methods Appropriately**:

- GET: Retrieve resources
- POST: Create new resources
- PUT: Update entire resources
- PATCH: Partially update resources
- DELETE: Remove resources

**Hierarchical Resource Structure**: Represent relationships through URL nesting.

```
GET /users/123/orders          # Get all orders for user 123
GET /users/123/orders/456      # Get specific order for user 123
POST /users/123/orders         # Create order for user 123
```

**Versioning**: Include API version in the URL or headers to manage changes over time.

```
/api/v1/users
/api/v2/users
```

**Filtering, Sorting, and Pagination**: Use query parameters for operations that don't fit the CRUD model.

```
GET /products?category=electronics&sort=price&order=asc&page=2&limit=20
```

**Consistent Naming Conventions**:

- Use plural nouns for collections: `/users`, `/products`
- Use lowercase letters
- Use hyphens for multi-word resources: `/user-profiles`

**HATEOAS (Hypermedia as the Engine of Application State)**: Include links in responses to guide clients to related resources.

```json
{
  "id": 123,
  "name": "John Doe",
  "links": {
    "self": "/users/123",
    "orders": "/users/123/orders",
    "profile": "/users/123/profile"
  }
}
```

---

## 3. HTTP Methods & Status Codes

### HTTP Methods

**GET**: Retrieves data from the server. Should be idempotent (multiple identical requests produce the same result) and have no side effects.

```
GET /api/users/123
GET /api/products?category=books
```

**POST**: Creates a new resource. Not idempotent—multiple identical requests may create multiple resources.

```
POST /api/users
Body: { "name": "John", "email": "john@example.com" }
```

**PUT**: Updates an entire resource or creates it if it doesn't exist. Idempotent—multiple identical requests produce the same result.

```
PUT /api/users/123
Body: { "name": "John Updated", "email": "john@example.com", "age": 30 }
```

**PATCH**: Partially updates a resource. May or may not be idempotent depending on implementation.

```
PATCH /api/users/123
Body: { "email": "newemail@example.com" }
```

**DELETE**: Removes a resource. Idempotent—deleting the same resource multiple times results in the same state.

```
DELETE /api/users/123
```

**HEAD**: Similar to GET but returns only headers, no body. Useful for checking if a resource exists or getting metadata.

**OPTIONS**: Returns the HTTP methods supported by a resource. Used in CORS preflight requests.

### HTTP Status Codes

Status codes indicate the outcome of an HTTP request. They're grouped into five categories:

**1xx: Informational** (rarely used in REST APIs)

- 100 Continue: Initial part of request received, client should continue
- 101 Switching Protocols: Server is switching protocols as requested

**2xx: Success**

- 200 OK: Request succeeded (GET, PUT, PATCH)
- 201 Created: Resource successfully created (POST)
- 202 Accepted: Request accepted but processing not complete (async operations)
- 204 No Content: Request succeeded but no content to return (DELETE)

**3xx: Redirection**

- 301 Moved Permanently: Resource permanently moved to new URL
- 302 Found: Resource temporarily at different URL
- 304 Not Modified: Resource hasn't changed since last request (caching)

**4xx: Client Errors**

- 400 Bad Request: Invalid request syntax or parameters
- 401 Unauthorized: Authentication required or failed
- 403 Forbidden: Server understood request but refuses to authorize it
- 404 Not Found: Resource doesn't exist
- 405 Method Not Allowed: HTTP method not supported for this resource
- 409 Conflict: Request conflicts with current server state (e.g., duplicate)
- 422 Unprocessable Entity: Request syntax correct but semantically invalid
- 429 Too Many Requests: Rate limit exceeded

**5xx: Server Errors**

- 500 Internal Server Error: Generic server error
- 501 Not Implemented: Server doesn't support requested functionality
- 502 Bad Gateway: Invalid response from upstream server
- 503 Service Unavailable: Server temporarily unavailable (maintenance, overload)
- 504 Gateway Timeout: Upstream server didn't respond in time

### Status Code Selection Guide

```
POST /users
→ 201 Created (success)
→ 400 Bad Request (validation failed)
→ 409 Conflict (user already exists)

GET /users/123
→ 200 OK (user found)
→ 404 Not Found (user doesn't exist)

PUT /users/123
→ 200 OK (updated successfully)
→ 404 Not Found (user doesn't exist)

DELETE /users/123
→ 204 No Content (deleted successfully)
→ 404 Not Found (user doesn't exist)

Any request
→ 401 Unauthorized (not authenticated)
→ 403 Forbidden (authenticated but not authorized)
→ 500 Internal Server Error (unexpected server error)
```

---

## 4. Middleware & Request Flow

Middleware functions are code that executes between receiving a request and sending a response. They have access to the request object, response object, and the next middleware function in the chain.

### How Middleware Works

Middleware creates a pipeline where each function can:

- Execute code before the route handler
- Modify the request or response objects
- End the request-response cycle
- Call the next middleware function in the stack

If a middleware function doesn't end the request-response cycle, it must call `next()` to pass control to the next middleware, or the request will hang.

### Request Flow Example

```
Client Request
    ↓
Logger Middleware (logs request details)
    ↓
CORS Middleware (handles cross-origin requests)
    ↓
Body Parser Middleware (parses JSON body)
    ↓
Authentication Middleware (verifies JWT token)
    ↓
Authorization Middleware (checks permissions)
    ↓
Route Handler (executes business logic)
    ↓
Error Handling Middleware (catches errors)
    ↓
Response to Client
```

### Types of Middleware

**Application-Level Middleware**: Applied to the entire application or specific routes.

```javascript
// Express.js example
app.use(express.json()); // Applies to all routes

app.use('/api', authMiddleware); // Applies to routes starting with /api
```

**Router-Level Middleware**: Applied to specific routers.

```javascript
const router = express.Router();
router.use(validationMiddleware);
router.get('/users', getUsers);
```

**Error-Handling Middleware**: Catches errors thrown in previous middleware or route handlers.

```javascript
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Something went wrong!' });
});
```

**Built-in Middleware**: Provided by the framework (JSON parsing, static files, etc.).

**Third-Party Middleware**: External packages like CORS, helmet, compression, etc.

### Common Middleware Use Cases

**Logging**: Record request details for debugging and monitoring.

```javascript
function loggerMiddleware(req, res, next) {
  console.log(`${req.method} ${req.url} - ${new Date().toISOString()}`);
  next();
}
```

**Authentication**: Verify user identity before allowing access.

```javascript
function authMiddleware(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  try {
    const decoded = jwt.verify(token, SECRET_KEY);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
}
```

**Request Validation**: Ensure incoming data meets requirements.

```javascript
function validateUserMiddleware(req, res, next) {
  const { email, password } = req.body;
  if (!email || !password) {
    return res.status(400).json({ error: 'Email and password required' });
  }
  if (!email.includes('@')) {
    return res.status(400).json({ error: 'Invalid email format' });
  }
  next();
}
```

**Rate Limiting**: Prevent abuse by limiting request frequency.

```javascript
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});

app.use('/api/', limiter);
```

**CORS Handling**: Manage cross-origin resource sharing.

```javascript
const cors = require('cors');
app.use(cors({
  origin: 'https://example.com',
  credentials: true
}));
```

### Middleware Execution Order

Order matters! Middleware executes in the order it's defined.

```javascript
// Correct order
app.use(logger);           // Log first
app.use(cors());           // Handle CORS
app.use(express.json());   // Parse body
app.use(authenticate);     // Then authenticate
app.use('/api', routes);   // Then handle routes
app.use(errorHandler);     // Catch errors last
```

---

## 5. Authentication vs Authorization

Authentication and authorization are distinct security concepts that work together to protect resources.

### Authentication

Authentication answers the question: "Who are you?" It's the process of verifying a user's identity.

**Common Authentication Methods:**

**Session-Based Authentication**:

1. User submits credentials (username/password)
2. Server verifies credentials against database
3. Server creates a session and stores it (in memory, Redis, database)
4. Server sends session ID to client as a cookie
5. Client includes cookie in subsequent requests
6. Server looks up session to identify user

Pros: Simple, server controls sessions, can revoke immediately
Cons: Doesn't scale well (requires server-side storage), issues with multiple servers

**Token-Based Authentication (JWT)**:

1. User submits credentials
2. Server verifies credentials
3. Server generates a signed JSON Web Token containing user info
4. Client stores token (localStorage, sessionStorage, cookie)
5. Client includes token in Authorization header for requests
6. Server verifies token signature and extracts user info

Pros: Stateless (no server-side storage), scales well, works across domains
Cons: Can't revoke tokens before expiration, token size larger than session ID

**OAuth 2.0**: Delegated authorization protocol allowing third-party access without sharing credentials. Common for "Login with Google/Facebook" features.

**Multi-Factor Authentication (MFA)**: Requires multiple forms of verification (password + SMS code, password + authenticator app).

### Authorization

Authorization answers the question: "What are you allowed to do?" It determines which resources and operations an authenticated user can access.

**Authorization Models:**

**Role-Based Access Control (RBAC)**: Users are assigned roles, and roles have permissions.

```
Roles: Admin, Editor, Viewer

Admin:
  - Can create, read, update, delete all resources
  - Can manage users

Editor:
  - Can create, read, update own resources
  - Can read all resources

Viewer:
  - Can only read resources
```

**Attribute-Based Access Control (ABAC)**: Access decisions based on attributes of the user, resource, and environment.

```
Allow if:
  user.department === resource.department AND
  user.level >= 3 AND
  time.hour >= 9 AND time.hour <= 17
```

**Access Control Lists (ACL)**: Specific permissions assigned to individual users or groups for specific resources.

```
Document ID 123:
  - User Alice: read, write
  - User Bob: read
  - Group Admins: read, write, delete
```

### Implementation Examples

**Basic Authentication Flow:**

```javascript
// Registration
async function register(req, res) {
  const { email, password, role } = req.body;
  
  // Hash password
  const hashedPassword = await bcrypt.hash(password, 10);
  
  // Store user
  const user = await User.create({
    email,
    password: hashedPassword,
    role: role || 'user'
  });
  
  res.status(201).json({ message: 'User created successfully' });
}

// Login
async function login(req, res) {
  const { email, password } = req.body;
  
  // Find user
  const user = await User.findOne({ email });
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Verify password
  const validPassword = await bcrypt.compare(password, user.password);
  if (!validPassword) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Generate JWT
  const token = jwt.sign(
    { id: user.id, email: user.email, role: user.role },
    SECRET_KEY,
    { expiresIn: '24h' }
  );
  
  res.json({ token });
}
```

**Authorization Middleware:**

```javascript
// Check if user is authenticated
function authenticate(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ error: 'Authentication required' });
  }
  
  try {
    const decoded = jwt.verify(token, SECRET_KEY);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid or expired token' });
  }
}

// Check if user has required role
function authorize(...allowedRoles) {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    if (!allowedRoles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    
    next();
  };
}

// Usage
app.get('/admin/users', 
  authenticate, 
  authorize('admin'), 
  getUsers
);

app.put('/posts/:id', 
  authenticate, 
  authorize('admin', 'editor'), 
  updatePost
);
```

**Resource-Level Authorization:**

```javascript
// Check if user owns the resource
async function authorizeOwner(req, res, next) {
  const postId = req.params.id;
  const post = await Post.findById(postId);
  
  if (!post) {
    return res.status(404).json({ error: 'Post not found' });
  }
  
  // Allow if user is owner or admin
  if (post.authorId !== req.user.id && req.user.role !== 'admin') {
    return res.status(403).json({ error: 'Not authorized to modify this post' });
  }
  
  req.post = post;
  next();
}

// Usage
app.delete('/posts/:id', 
  authenticate, 
  authorizeOwner, 
  deletePost
);
```

### Security Best Practices

**For Authentication:**

- Never store passwords in plain text (use bcrypt, Argon2, or scrypt)
- Use HTTPS to encrypt data in transit
- Implement rate limiting on login endpoints
- Use strong, long-lived secrets for JWT signing
- Set appropriate token expiration times
- Consider refresh tokens for long-lived sessions
- Implement account lockout after failed login attempts

**For Authorization:**

- Follow the principle of least privilege
- Default to deny access (opt-in rather than opt-out)
- Validate authorization on every request (never trust client-side checks)
- Check authorization at the resource level, not just at the route level
- Log authorization failures for security monitoring
- Regularly audit and review permissions

### Authentication vs Authorization Summary

| Aspect | Authentication | Authorization |
|--------|----------------|---------------|
| Question | Who are you? | What can you do? |
| Process | Verifies identity | Grants permissions |
| When | First step, during login | After authentication, on each request |
| Methods | Passwords, tokens, biometrics | Roles, permissions, ACLs |
| Failure | 401 Unauthorized | 403 Forbidden |
| Visibility | User knows when they're not authenticated | User may not know why they're forbidden |

---

## Quick Reference Cheat Sheet

### HTTP Status Codes

- 200: OK
- 201: Created
- 204: No Content
- 400: Bad Request
- 401: Unauthorized (not authenticated)
- 403: Forbidden (not authorized)
- 404: Not Found
- 500: Internal Server Error

### REST API URL Structure

```
GET    /resources          # List all
GET    /resources/123      # Get one
POST   /resources          # Create new
PUT    /resources/123      # Update entire
PATCH  /resources/123      # Update partial
DELETE /resources/123      # Delete
```

### Middleware Pattern

```javascript
function middleware(req, res, next) {
  // Do something with req/res
  // Then either:
  next();                    // Continue to next middleware
  // OR
  res.json({ data });        // End the response
}
```

### Authentication vs Authorization

- **Authentication**: Verify identity → 401 if fails
- **Authorization**: Check permissions → 403 if fails
- Always authenticate before authorizing
