---
layout: ../../layout/main-layout.astro
---

<a href="/react">‚Üê React</a> <br /> <br />

# React Context API

## Table of Contents
1. [Introduction](#introduction)
2. [Core Concepts](#core-concepts)
3. [Creating Context](#creating-context)
4. [Provider Component](#provider-component)
5. [Consuming Context](#consuming-context)
6. [Multiple Contexts](#multiple-contexts)
7. [Advanced Patterns](#advanced-patterns)
8. [Performance Optimization](#performance-optimization)
9. [Best Practices](#best-practices)
10. [Common Pitfalls](#common-pitfalls)
11. [Real-World Examples](#real-world-examples)

## Introduction

The Context API is a React feature that enables you to share data across the component tree without passing props manually at every level. It's designed to solve the "prop drilling" problem where data needs to be passed through multiple intermediate components.

Context is ideal for sharing data that can be considered "global" for a tree of React components, such as the current authenticated user, theme preferences, or language settings.

## Core Concepts

### What is Context?

Context provides a way to pass data through the component tree without having to pass props down manually at every level. It consists of three main parts:

- **React.createContext**: Creates a Context object
- **Provider**: Supplies the context value to child components
- **Consumer**: Subscribes to context changes (or use the `useContext` hook)

### When to Use Context

Use Context when:
- Data needs to be accessible by many components at different nesting levels
- You want to avoid prop drilling through intermediate components
- The data is relatively stable or changes infrequently
- You're sharing global state like themes, user authentication, or preferences

Avoid Context when:
- Props would only pass through 1-2 levels
- You need high-frequency updates (consider state management libraries)
- Local component state would suffice

## Creating Context

### Basic Syntax

```javascript
import React from 'react';

const MyContext = React.createContext(defaultValue);
```

### With Default Values

```javascript
const ThemeContext = React.createContext({
  theme: 'light',
  toggleTheme: () => {}
});
```

### TypeScript Example

```typescript
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = React.createContext<ThemeContextType | undefined>(undefined);
```

## Provider Component

The Provider component allows consuming components to subscribe to context changes.

### Basic Provider

```javascript
function App() {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <ChildComponent />
    </ThemeContext.Provider>
  );
}
```

### Provider with State Management

```javascript
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
  };

  const value = {
    theme,
    toggleTheme
  };

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}
```

### Provider with useReducer

```javascript
const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function CountProvider({ children }) {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <CountContext.Provider value={{ state, dispatch }}>
      {children}
    </CountContext.Provider>
  );
}
```

## Consuming Context

### Using useContext Hook (Recommended)

```javascript
import { useContext } from 'react';

function ThemedButton() {
  const { theme, toggleTheme } = useContext(ThemeContext);

  return (
    <button 
      style={{ background: theme === 'light' ? '#fff' : '#333' }}
      onClick={toggleTheme}
    >
      Toggle Theme
    </button>
  );
}
```

### Using Consumer Component (Legacy)

```javascript
function ThemedButton() {
  return (
    <ThemeContext.Consumer>
      {({ theme, toggleTheme }) => (
        <button 
          style={{ background: theme === 'light' ? '#fff' : '#333' }}
          onClick={toggleTheme}
        >
          Toggle Theme
        </button>
      )}
    </ThemeContext.Consumer>
  );
}
```

### Custom Hook Pattern

```javascript
function useTheme() {
  const context = useContext(ThemeContext);
  
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  
  return context;
}

// Usage
function Component() {
  const { theme, toggleTheme } = useTheme();
  // ...
}
```

## Multiple Contexts

### Nested Providers

```javascript
function App() {
  return (
    <ThemeProvider>
      <UserProvider>
        <LanguageProvider>
          <MainApp />
        </LanguageProvider>
      </UserProvider>
    </ThemeProvider>
  );
}
```

### Consuming Multiple Contexts

```javascript
function ProfileCard() {
  const { theme } = useContext(ThemeContext);
  const { user } = useContext(UserContext);
  const { language } = useContext(LanguageContext);

  return (
    <div style={{ background: theme === 'light' ? '#fff' : '#333' }}>
      <h1>{user.name}</h1>
      <p>{language === 'en' ? 'Welcome' : 'Bienvenido'}</p>
    </div>
  );
}
```

### Combining Contexts

```javascript
function AppProviders({ children }) {
  return (
    <ThemeProvider>
      <UserProvider>
        <LanguageProvider>
          {children}
        </LanguageProvider>
      </UserProvider>
    </ThemeProvider>
  );
}

// Usage
function App() {
  return (
    <AppProviders>
      <MainApp />
    </AppProviders>
  );
}
```

## Advanced Patterns

### Context with Multiple Values

```javascript
const AppContext = React.createContext();

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  const [notifications, setNotifications] = useState([]);

  const value = {
    user,
    setUser,
    theme,
    setTheme,
    notifications,
    setNotifications
  };

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}
```

### Lazy Context Initialization

```javascript
function ExpensiveProvider({ children }) {
  const [value] = useState(() => {
    // Expensive computation only runs once
    return computeExpensiveValue();
  });

  return (
    <ExpensiveContext.Provider value={value}>
      {children}
    </ExpensiveContext.Provider>
  );
}
```

### Context with Local Storage

```javascript
function SettingsProvider({ children }) {
  const [settings, setSettings] = useState(() => {
    const saved = localStorage.getItem('settings');
    return saved ? JSON.parse(saved) : defaultSettings;
  });

  useEffect(() => {
    localStorage.setItem('settings', JSON.stringify(settings));
  }, [settings]);

  return (
    <SettingsContext.Provider value={{ settings, setSettings }}>
      {children}
    </SettingsContext.Provider>
  );
}
```

### Context with API Integration

```javascript
function DataProvider({ children }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchData()
      .then(result => {
        setData(result);
        setLoading(false);
      })
      .catch(err => {
        setError(err);
        setLoading(false);
      });
  }, []);

  const value = { data, loading, error, refetch: fetchData };

  return <DataContext.Provider value={value}>{children}</DataContext.Provider>;
}
```

## Performance Optimization

### Memoizing Context Value

```javascript
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  // Memoize the context value to prevent unnecessary re-renders
  const value = useMemo(() => ({
    theme,
    toggleTheme: () => setTheme(prev => prev === 'light' ? 'dark' : 'light')
  }), [theme]);

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}
```

### Splitting Contexts

Instead of one large context, split into smaller, focused contexts:

```javascript
// Instead of this:
const AppContext = React.createContext({ user, theme, settings, notifications });

// Do this:
const UserContext = React.createContext();
const ThemeContext = React.createContext();
const SettingsContext = React.createContext();
const NotificationsContext = React.createContext();
```

### Selective Context Consumption

```javascript
// Only subscribe to the data you need
function UserName() {
  const { user } = useContext(AppContext); // Only re-renders when user changes
  return <span>{user.name}</span>;
}

function ThemeButton() {
  const { theme } = useContext(AppContext); // Only re-renders when theme changes
  return <button className={theme}>Click me</button>;
}
```

### Using React.memo with Context

```javascript
const ExpensiveComponent = React.memo(({ data }) => {
  // Expensive rendering logic
  return <div>{/* ... */}</div>;
});

function Parent() {
  const { theme } = useContext(ThemeContext);
  const [data] = useState(expensiveData);

  return <ExpensiveComponent data={data} />;
  // ExpensiveComponent won't re-render when theme changes
}
```

## Best Practices

### 1. Create Custom Hooks

Always create custom hooks for accessing context:

```javascript
// Good
function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}

// Usage
const { user, login, logout } = useAuth();
```

### 2. Separate Context Logic

Keep context logic in separate files:

```javascript
// contexts/ThemeContext.js
export const ThemeContext = React.createContext();
export const ThemeProvider = ({ children }) => { /* ... */ };
export const useTheme = () => { /* ... */ };
```

### 3. Provide Default Values

Always provide sensible default values:

```javascript
const ThemeContext = React.createContext({
  theme: 'light',
  toggleTheme: () => {
    console.warn('toggleTheme called outside of ThemeProvider');
  }
});
```

### 4. Type Safety with TypeScript

```typescript
interface User {
  id: string;
  name: string;
  email: string;
}

interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  isLoading: boolean;
}

const AuthContext = React.createContext<AuthContextType | undefined>(undefined);

export function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
```

### 5. Composition Over Large Contexts

```javascript
// Bad: One giant context
const AppContext = React.createContext({
  user, theme, language, notifications, settings, cart, orders
});

// Good: Multiple focused contexts
<UserProvider>
  <ThemeProvider>
    <CartProvider>
      <App />
    </CartProvider>
  </ThemeProvider>
</UserProvider>
```

## Common Pitfalls

### 1. Creating New Objects on Every Render

```javascript
// Bad - Creates new object every render
function Provider({ children }) {
  const [user, setUser] = useState(null);
  return (
    <UserContext.Provider value={{ user, setUser }}>
      {children}
    </UserContext.Provider>
  );
}

// Good - Memoized value
function Provider({ children }) {
  const [user, setUser] = useState(null);
  const value = useMemo(() => ({ user, setUser }), [user]);
  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
}
```

### 2. Not Checking for Undefined Context

```javascript
// Bad
function Component() {
  const context = useContext(MyContext);
  return <div>{context.value}</div>; // May crash if used outside provider
}

// Good
function Component() {
  const context = useContext(MyContext);
  if (!context) {
    throw new Error('Component must be used within MyProvider');
  }
  return <div>{context.value}</div>;
}
```

### 3. Overusing Context

```javascript
// Bad - Using context for local state
function Parent() {
  return (
    <CountProvider>
      <Child />
    </CountProvider>
  );
}

// Good - Use local state instead
function Parent() {
  const [count, setCount] = useState(0);
  return <Child count={count} setCount={setCount} />;
}
```

### 4. Unnecessary Re-renders

```javascript
// Bad - All consumers re-render when any value changes
const value = { user, theme, settings, notifications };

// Good - Split into separate contexts
<UserContext.Provider value={user}>
  <ThemeContext.Provider value={theme}>
    {children}
  </ThemeContext.Provider>
</UserContext.Provider>
```

## Real-World Examples

### Authentication Context

```javascript
const AuthContext = React.createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Check if user is logged in
    const unsubscribe = onAuthStateChanged(auth, (user) => {
      setUser(user);
      setLoading(false);
    });
    return unsubscribe;
  }, []);

  const login = async (email, password) => {
    try {
      const result = await signInWithEmailAndPassword(auth, email, password);
      setUser(result.user);
    } catch (error) {
      throw error;
    }
  };

  const logout = async () => {
    try {
      await signOut(auth);
      setUser(null);
    } catch (error) {
      throw error;
    }
  };

  const value = useMemo(() => ({
    user,
    login,
    logout,
    loading
  }), [user, loading]);

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}
```

### Theme Context with Persistence

```javascript
const ThemeContext = React.createContext();

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState(() => {
    const saved = localStorage.getItem('theme');
    return saved || 'light';
  });

  useEffect(() => {
    localStorage.setItem('theme', theme);
    document.documentElement.setAttribute('data-theme', theme);
  }, [theme]);

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  const value = useMemo(() => ({
    theme,
    toggleTheme
  }), [theme]);

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}
```

### Shopping Cart Context

```javascript
const CartContext = React.createContext();

export function CartProvider({ children }) {
  const [items, setItems] = useState([]);

  const addItem = (product) => {
    setItems(prev => {
      const existing = prev.find(item => item.id === product.id);
      if (existing) {
        return prev.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        );
      }
      return [...prev, { ...product, quantity: 1 }];
    });
  };

  const removeItem = (productId) => {
    setItems(prev => prev.filter(item => item.id !== productId));
  };

  const updateQuantity = (productId, quantity) => {
    if (quantity <= 0) {
      removeItem(productId);
      return;
    }
    setItems(prev =>
      prev.map(item =>
        item.id === productId ? { ...item, quantity } : item
      )
    );
  };

  const clearCart = () => {
    setItems([]);
  };

  const total = items.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0
  );

  const value = useMemo(() => ({
    items,
    addItem,
    removeItem,
    updateQuantity,
    clearCart,
    total,
    itemCount: items.length
  }), [items, total]);

  return (
    <CartContext.Provider value={value}>
      {children}
    </CartContext.Provider>
  );
}

export function useCart() {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within CartProvider');
  }
  return context;
}
```

### Notification Context

```javascript
const NotificationContext = React.createContext();

export function NotificationProvider({ children }) {
  const [notifications, setNotifications] = useState([]);

  const addNotification = (message, type = 'info') => {
    const id = Date.now();
    setNotifications(prev => [...prev, { id, message, type }]);

    // Auto-remove after 5 seconds
    setTimeout(() => {
      removeNotification(id);
    }, 5000);
  };

  const removeNotification = (id) => {
    setNotifications(prev => prev.filter(notif => notif.id !== id));
  };

  const value = useMemo(() => ({
    notifications,
    addNotification,
    removeNotification,
    success: (msg) => addNotification(msg, 'success'),
    error: (msg) => addNotification(msg, 'error'),
    warning: (msg) => addNotification(msg, 'warning'),
    info: (msg) => addNotification(msg, 'info')
  }), [notifications]);

  return (
    <NotificationContext.Provider value={value}>
      {children}
    </NotificationContext.Provider>
  );
}

export function useNotification() {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error('useNotification must be used within NotificationProvider');
  }
  return context;
}
```

---

## Summary

The Context API is a powerful feature in React for sharing data across component trees. Key takeaways:

- Use Context for global or semi-global state that many components need
- Always memoize context values to prevent unnecessary re-renders
- Create custom hooks for accessing context values
- Split large contexts into smaller, focused ones
- Validate that components are used within the appropriate Provider
- Consider performance implications and optimize accordingly
- Don't overuse Context - props and local state are often better solutions

Context is most effective when combined with other React patterns and used thoughtfully as part of your application's architecture.